{"ast":null,"code":"class DecodedParamCache {\n  constructor() {\n    this.paramsMap = /* @__PURE__ */new Map();\n    this.registeredParams = /* @__PURE__ */new Map();\n  }\n  set(param, stringifiedValue, decodedValue, decode) {\n    this.paramsMap.set(param, {\n      stringified: stringifiedValue,\n      decoded: decodedValue,\n      decode\n    });\n  }\n  has(param, stringifiedValue, decode) {\n    if (!this.paramsMap.has(param)) return false;\n    const cachedParam = this.paramsMap.get(param);\n    if (!cachedParam) return false;\n    return cachedParam.stringified === stringifiedValue && (decode == null || cachedParam.decode === decode);\n  }\n  get(param) {\n    var _a;\n    if (this.paramsMap.has(param)) return (_a = this.paramsMap.get(param)) == null ? void 0 : _a.decoded;\n    return void 0;\n  }\n  registerParams(paramNames) {\n    for (const param of paramNames) {\n      const currValue = this.registeredParams.get(param) || 0;\n      this.registeredParams.set(param, currValue + 1);\n    }\n  }\n  unregisterParams(paramNames) {\n    for (const param of paramNames) {\n      const value = (this.registeredParams.get(param) || 0) - 1;\n      if (value <= 0) {\n        this.registeredParams.delete(param);\n        if (this.paramsMap.has(param)) {\n          this.paramsMap.delete(param);\n        }\n      } else {\n        this.registeredParams.set(param, value);\n      }\n    }\n  }\n  clear() {\n    this.paramsMap.clear();\n    this.registeredParams.clear();\n  }\n}\nconst decodedParamCache = new DecodedParamCache();\nexport { DecodedParamCache, decodedParamCache };","map":{"version":3,"mappings":"AAcO,MAAMA,kBAAkB;EAI7BC,cAAc;IACZ,KAAKC,YAAY,mBAAIC,KAAI;IACzB,KAAKC,mBAAmB,mBAAID,KAAI;EAClC;EAEAE,IACEC,OACAC,kBACAC,cACAC,QACA;IACA,KAAKP,UAAUG,IAAIC,OAAO;MACxBI,aAAaH;MACbI,SAASH;MACTC;IACF,CAAC;EACH;EAKAG,IAAIN,OAAeC,kBAAgCE,QAAmB;IACpE,IAAI,CAAC,KAAKP,UAAUU,IAAIN,KAAK,GAAG,OAAO;IACvC,MAAMO,cAAc,KAAKX,UAAUY,IAAIR,KAAK;IAC5C,IAAI,CAACO,aAAa,OAAO;IAEzB,OACEA,YAAYH,gBAAgBH,qBAC3BE,UAAU,QAAQI,YAAYJ,WAAWA;EAE9C;EAEAK,IAAIR,OAAe;IAlDrB;IAmDI,IAAI,KAAKJ,UAAUU,IAAIN,KAAK,GAAG,QAAOS,UAAKb,UAAUY,IAAIR,KAAK,MAAxB,mBAA2BK;IACjE,OAAO;EACT;EAKAK,eAAeC,YAAsB;IACnC,WAAWX,SAASW,YAAY;MAC9B,MAAMC,YAAY,KAAKd,iBAAiBU,IAAIR,KAAK,KAAK;MACtD,KAAKF,iBAAiBC,IAAIC,OAAOY,YAAY,CAAC;IAChD;EACF;EAMAC,iBAAiBF,YAAsB;IACrC,WAAWX,SAASW,YAAY;MAC9B,MAAMG,SAAS,KAAKhB,iBAAiBU,IAAIR,KAAK,KAAK,KAAK;MACxD,IAAIc,SAAS,GAAG;QACd,KAAKhB,iBAAiBiB,OAAOf,KAAK;QAClC,IAAI,KAAKJ,UAAUU,IAAIN,KAAK,GAAG;UAC7B,KAAKJ,UAAUmB,OAAOf,KAAK;QAC7B;MACF,OAAO;QACL,KAAKF,iBAAiBC,IAAIC,OAAOc,KAAK;MACxC;IACF;EACF;EAEAE,QAAQ;IACN,KAAKpB,UAAUoB,OAAM;IACrB,KAAKlB,iBAAiBkB,OAAM;EAC9B;AACF;AAEO,MAAMC,oBAAoB,IAAIvB,mBAAkB","names":["DecodedParamCache","constructor","paramsMap","Map","registeredParams","set","param","stringifiedValue","decodedValue","decode","stringified","decoded","has","cachedParam","get","_a","registerParams","paramNames","currValue","unregisterParams","value","delete","clear","decodedParamCache"],"sources":["/Users/elahehaslani/Documents/GitHub/movie-ticket-booking/node_modules/use-query-params/src/decodedParamCache.ts"],"sourcesContent":["type EncodedValue = string | (string | null)[] | null | undefined;\n\ntype CachedParam = {\n  stringified: EncodedValue;\n  decoded: any;\n  decode: Function;\n};\n\n/**\n * simple cache that keeps values around so long as something\n * has registered interest in it (typically via calling useQueryParams).\n * Caches based on the stringified value as the key and the\n * last passed in decode function.\n */\nexport class DecodedParamCache {\n  private paramsMap: Map<string, CachedParam>;\n  private registeredParams: Map<string, number>;\n\n  constructor() {\n    this.paramsMap = new Map();\n    this.registeredParams = new Map();\n  }\n\n  set(\n    param: string,\n    stringifiedValue: EncodedValue,\n    decodedValue: any,\n    decode: Function\n  ) {\n    this.paramsMap.set(param, {\n      stringified: stringifiedValue,\n      decoded: decodedValue,\n      decode,\n    });\n  }\n\n  /**\n   * A param has been cached if the stringified value and decode function matches\n   */\n  has(param: string, stringifiedValue: EncodedValue, decode?: Function) {\n    if (!this.paramsMap.has(param)) return false;\n    const cachedParam = this.paramsMap.get(param);\n    if (!cachedParam) return false;\n\n    return (\n      cachedParam.stringified === stringifiedValue &&\n      (decode == null || cachedParam.decode === decode)\n    );\n  }\n\n  get(param: string) {\n    if (this.paramsMap.has(param)) return this.paramsMap.get(param)?.decoded;\n    return undefined;\n  }\n\n  /**\n   * Register interest in a set of param names. When these go to 0 they are cleaned out.\n   */\n  registerParams(paramNames: string[]) {\n    for (const param of paramNames) {\n      const currValue = this.registeredParams.get(param) || 0;\n      this.registeredParams.set(param, currValue + 1);\n    }\n  }\n\n  /**\n   * Unregister interest in a set of param names. If there is no remaining interest,\n   * remove the decoded value from the cache to prevent memory leaks.\n   */\n  unregisterParams(paramNames: string[]) {\n    for (const param of paramNames) {\n      const value = (this.registeredParams.get(param) || 0) - 1;\n      if (value <= 0) {\n        this.registeredParams.delete(param);\n        if (this.paramsMap.has(param)) {\n          this.paramsMap.delete(param);\n        }\n      } else {\n        this.registeredParams.set(param, value);\n      }\n    }\n  }\n\n  clear() {\n    this.paramsMap.clear();\n    this.registeredParams.clear();\n  }\n}\n\nexport const decodedParamCache = new DecodedParamCache();\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}