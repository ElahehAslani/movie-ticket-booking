{"ast":null,"code":"import shallowEqual from \"./shallowEqual\";\nfunction getLatestDecodedValues(parsedParams, paramConfigMap, decodedParamCache) {\n  const decodedValues = {};\n  const paramNames = Object.keys(paramConfigMap);\n  for (const paramName of paramNames) {\n    const paramConfig = paramConfigMap[paramName];\n    const encodedValue = parsedParams[paramName];\n    let decodedValue;\n    if (decodedParamCache.has(paramName, encodedValue, paramConfig.decode)) {\n      decodedValue = decodedParamCache.get(paramName);\n    } else {\n      decodedValue = paramConfig.decode(encodedValue);\n      if (paramConfig.equals && decodedParamCache.has(paramName, encodedValue)) {\n        const oldDecodedValue = decodedParamCache.get(paramName);\n        if (paramConfig.equals(decodedValue, oldDecodedValue)) {\n          decodedValue = oldDecodedValue;\n        }\n      }\n      if (decodedValue !== void 0) {\n        decodedParamCache.set(paramName, encodedValue, decodedValue, paramConfig.decode);\n      }\n    }\n    if (decodedValue === void 0 && paramConfig.default !== void 0) {\n      decodedValue = paramConfig.default;\n    }\n    decodedValues[paramName] = decodedValue;\n  }\n  return decodedValues;\n}\nfunction makeStableGetLatestDecodedValues() {\n  let prevDecodedValues;\n  function stableGetLatest(parsedParams, paramConfigMap, decodedParamCache) {\n    const decodedValues = getLatestDecodedValues(parsedParams, paramConfigMap, decodedParamCache);\n    if (prevDecodedValues != null && shallowEqual(prevDecodedValues, decodedValues)) {\n      return prevDecodedValues;\n    }\n    prevDecodedValues = decodedValues;\n    return decodedValues;\n  }\n  return stableGetLatest;\n}\nexport { getLatestDecodedValues, makeStableGetLatestDecodedValues };","map":{"version":3,"mappings":"AAMA,OAAOA,kBAAkB;AAMlB,SAASC,uBACdC,cACAC,gBACAC,mBACA;EACA,MAAMC,gBAAkD,CAAC;EAIzD,MAAMC,aAAaC,OAAOC,KAAKL,cAAc;EAC7C,WAAWM,aAAaH,YAAY;IAElC,MAAMI,cAAcP,eAAeM;IACnC,MAAME,eAAeT,aAAaO;IAGlC,IAAIG;IACJ,IAAIR,kBAAkBS,IAAIJ,WAAWE,cAAcD,YAAYI,MAAM,GAAG;MACtEF,eAAeR,kBAAkBW,IAAIN,SAAS;IAChD,OAAO;MACLG,eAAeF,YAAYI,OAAOH,YAAY;MAK9C,IACED,YAAYM,UACZZ,kBAAkBS,IAAIJ,WAAWE,YAAY,GAC7C;QACA,MAAMM,kBAAkBb,kBAAkBW,IAAIN,SAAS;QACvD,IAAIC,YAAYM,OAAOJ,cAAcK,eAAe,GAAG;UACrDL,eAAeK;QACjB;MACF;MAGA,IAAIL,iBAAiB,QAAW;QAC9BR,kBAAkBc,IAChBT,WACAE,cACAC,cACAF,YAAYI,OACd;MACF;IACF;IAIA,IAAIF,iBAAiB,UAAaF,YAAYS,YAAY,QAAW;MACnEP,eAAeF,YAAYS;IAC7B;IAEAd,cAAcI,aAA6BG;EAC7C;EAEA,OAAOP;AACT;AAMO,SAASe,mCAAmC;EACjD,IAAIC;EAEJ,SAASC,gBACPpB,cACAC,gBACAC,mBACA;IACA,MAAMC,gBAAgBJ,uBACpBC,cACAC,gBACAC,kBACF;IACA,IACEiB,qBAAqB,QACrBrB,aAAaqB,mBAAmBhB,aAAa,GAC7C;MACA,OAAOgB;IACT;IACAA,oBAAoBhB;IACpB,OAAOA;EACT;EAEA,OAAOiB;AACT","names":["shallowEqual","getLatestDecodedValues","parsedParams","paramConfigMap","decodedParamCache","decodedValues","paramNames","Object","keys","paramName","paramConfig","encodedValue","decodedValue","has","decode","get","equals","oldDecodedValue","set","default","makeStableGetLatestDecodedValues","prevDecodedValues","stableGetLatest"],"sources":["/Users/elahehaslani/Work/Sample-Project/ticket-booking/ticket-booking/node_modules/use-query-params/src/latestValues.ts"],"sourcesContent":["import {\n  DecodedValueMap,\n  EncodedQuery,\n  QueryParamConfigMap,\n} from 'serialize-query-params';\nimport { DecodedParamCache } from './decodedParamCache';\nimport shallowEqual from './shallowEqual';\n\n/**\n * Helper to get the latest decoded values with smart caching.\n * Abstracted into its own function to allow re-use in a functional setter (#26)\n */\nexport function getLatestDecodedValues<QPCMap extends QueryParamConfigMap>(\n  parsedParams: EncodedQuery,\n  paramConfigMap: QPCMap,\n  decodedParamCache: DecodedParamCache\n) {\n  const decodedValues: Partial<DecodedValueMap<QPCMap>> = {};\n\n  // we have new encoded values, so let's get new decoded values.\n  // recompute new values but only for those that changed\n  const paramNames = Object.keys(paramConfigMap);\n  for (const paramName of paramNames) {\n    // do we have a new encoded value?\n    const paramConfig = paramConfigMap[paramName];\n    const encodedValue = parsedParams[paramName];\n\n    // if we have a new encoded value, re-decode. otherwise reuse cache\n    let decodedValue;\n    if (decodedParamCache.has(paramName, encodedValue, paramConfig.decode)) {\n      decodedValue = decodedParamCache.get(paramName);\n    } else {\n      decodedValue = paramConfig.decode(encodedValue);\n\n      // check if we had a cached value for this encoded value but a different encoder\n      // (sometimes people inline decode functions, e.g. withDefault...)\n      // AND we had a different equals check than ===\n      if (\n        paramConfig.equals &&\n        decodedParamCache.has(paramName, encodedValue)\n      ) {\n        const oldDecodedValue = decodedParamCache.get(paramName);\n        if (paramConfig.equals(decodedValue, oldDecodedValue)) {\n          decodedValue = oldDecodedValue;\n        }\n      }\n\n      // do not cache undefined values\n      if (decodedValue !== undefined) {\n        decodedParamCache.set(\n          paramName,\n          encodedValue,\n          decodedValue,\n          paramConfig.decode\n        );\n      }\n    }\n\n    // in case the decode function didn't interpret `default` for some reason,\n    // we can interpret it here as a backup\n    if (decodedValue === undefined && paramConfig.default !== undefined) {\n      decodedValue = paramConfig.default;\n    }\n\n    decodedValues[paramName as keyof QPCMap] = decodedValue;\n  }\n\n  return decodedValues as DecodedValueMap<QPCMap>;\n}\n\n/**\n * Wrap get latest so we use the same exact object if the current\n * values are shallow equal to the previous.\n */\nexport function makeStableGetLatestDecodedValues() {\n  let prevDecodedValues: DecodedValueMap<any> | undefined;\n\n  function stableGetLatest<QPCMap extends QueryParamConfigMap>(\n    parsedParams: EncodedQuery,\n    paramConfigMap: QPCMap,\n    decodedParamCache: DecodedParamCache\n  ) {\n    const decodedValues = getLatestDecodedValues(\n      parsedParams,\n      paramConfigMap,\n      decodedParamCache\n    );\n    if (\n      prevDecodedValues != null &&\n      shallowEqual(prevDecodedValues, decodedValues)\n    ) {\n      return prevDecodedValues;\n    }\n    prevDecodedValues = decodedValues;\n    return decodedValues;\n  }\n\n  return stableGetLatest;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}