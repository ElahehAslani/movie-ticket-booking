{"ast":null,"code":"function serializeUrlNameMap(paramConfigMap) {\n  let urlNameMapParts;\n  for (const paramName in paramConfigMap) {\n    if (paramConfigMap[paramName].urlName) {\n      const urlName = paramConfigMap[paramName].urlName;\n      const part = `${urlName}\\0${paramName}`;\n      if (!urlNameMapParts) urlNameMapParts = [part];else urlNameMapParts.push(part);\n    }\n  }\n  return urlNameMapParts ? urlNameMapParts.join(\"\\n\") : void 0;\n}\nfunction deserializeUrlNameMap(urlNameMapStr) {\n  if (!urlNameMapStr) return void 0;\n  return Object.fromEntries(urlNameMapStr.split(\"\\n\").map(part => part.split(\"\\0\")));\n}\nfunction applyUrlNames(encodedValues, paramConfigMap) {\n  var _a;\n  let newEncodedValues = {};\n  for (const paramName in encodedValues) {\n    if (((_a = paramConfigMap[paramName]) == null ? void 0 : _a.urlName) != null) {\n      newEncodedValues[paramConfigMap[paramName].urlName] = encodedValues[paramName];\n    } else {\n      newEncodedValues[paramName] = encodedValues[paramName];\n    }\n  }\n  return newEncodedValues;\n}\nexport { applyUrlNames, deserializeUrlNameMap, serializeUrlNameMap };","map":{"version":3,"mappings":"AAKO,SAASA,oBACdC,gBACoB;EACpB,IAAIC;EACJ,WAAWC,aAAaF,gBAAgB;IACtC,IAAIA,eAAeE,WAAWC,SAAS;MACrC,MAAMA,UAAUH,eAAeE,WAAWC;MAC1C,MAAMC,OAAO,GAAGD,YAAYD;MAC5B,IAAI,CAACD,iBAAiBA,kBAAkB,CAACG,IAAI,OACxCH,gBAAgBI,KAAKD,IAAI;IAChC;EACF;EAEA,OAAOH,kBAAkBA,gBAAgBK,KAAK,IAAI,IAAI;AACxD;AAKO,SAASC,sBACdC,eACoC;EACpC,IAAI,CAACA,eAAe,OAAO;EAE3B,OAAOC,OAAOC,YACZF,cAAcG,MAAM,IAAI,EAAEC,IAAKR,QAASA,KAAKO,MAAM,IAAI,CAAC,EAC1D;AACF;AAMO,SAASE,cACdC,eACAd,gBACA;EAzCF;EA0CE,IAAIe,mBAAkD,CAAC;EACvD,WAAWb,aAAaY,eAAe;IACrC,MAAIE,oBAAed,eAAf,mBAA2BC,YAAW,MAAM;MAC9CY,iBAAiBf,eAAeE,WAAWC,WACzCW,cAAcZ;IAClB,OAAO;MACLa,iBAAiBb,aAAaY,cAAcZ;IAC9C;EACF;EAEA,OAAOa;AACT","names":["serializeUrlNameMap","paramConfigMap","urlNameMapParts","paramName","urlName","part","push","join","deserializeUrlNameMap","urlNameMapStr","Object","fromEntries","split","map","applyUrlNames","encodedValues","newEncodedValues","_a"],"sources":["/Users/elahehaslani/Work/Sample-Project/ticket-booking/ticket-booking/node_modules/use-query-params/src/urlName.ts"],"sourcesContent":["import { EncodedValueMap, QueryParamConfigMap } from 'serialize-query-params';\n\n/**\n * Create an alias mapping using the optional `urlName` property on params\n */\nexport function serializeUrlNameMap(\n  paramConfigMap: QueryParamConfigMap\n): string | undefined {\n  let urlNameMapParts: string[] | undefined;\n  for (const paramName in paramConfigMap) {\n    if (paramConfigMap[paramName].urlName) {\n      const urlName = paramConfigMap[paramName].urlName;\n      const part = `${urlName}\\0${paramName}`;\n      if (!urlNameMapParts) urlNameMapParts = [part];\n      else urlNameMapParts.push(part);\n    }\n  }\n\n  return urlNameMapParts ? urlNameMapParts.join('\\n') : undefined;\n}\n\n/**\n * Converts the stringified alias/urlName map back into an object\n */\nexport function deserializeUrlNameMap(\n  urlNameMapStr: string | undefined\n): Record<string, string> | undefined {\n  if (!urlNameMapStr) return undefined;\n\n  return Object.fromEntries(\n    urlNameMapStr.split('\\n').map((part) => part.split('\\0'))\n  );\n}\n\n/**\n * converts { searchString: 'foo'} to { q: 'foo'} if the searchString\n * is configured to have \"q\" as its urlName.\n */\nexport function applyUrlNames(\n  encodedValues: Partial<EncodedValueMap<any>>,\n  paramConfigMap: QueryParamConfigMap\n) {\n  let newEncodedValues: Partial<EncodedValueMap<any>> = {};\n  for (const paramName in encodedValues) {\n    if (paramConfigMap[paramName]?.urlName != null) {\n      newEncodedValues[paramConfigMap[paramName].urlName!] =\n        encodedValues[paramName];\n    } else {\n      newEncodedValues[paramName] = encodedValues[paramName];\n    }\n  }\n\n  return newEncodedValues;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}