{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nfunction _gensync() {\n  const data = require(\"gensync\");\n  _gensync = function () {\n    return data;\n  };\n  return data;\n}\nvar _async = require(\"../gensync-utils/async\");\nvar _util = require(\"./util\");\nvar context = require(\"../index\");\nvar _plugin = require(\"./plugin\");\nvar _item = require(\"./item\");\nvar _configChain = require(\"./config-chain\");\nvar _deepArray = require(\"./helpers/deep-array\");\nfunction _traverse() {\n  const data = require(\"@babel/traverse\");\n  _traverse = function () {\n    return data;\n  };\n  return data;\n}\nvar _caching = require(\"./caching\");\nvar _options = require(\"./validation/options\");\nvar _plugins = require(\"./validation/plugins\");\nvar _configApi = require(\"./helpers/config-api\");\nvar _partial = require(\"./partial\");\nvar _configError = require(\"../errors/config-error\");\nvar _default = _gensync()(function* loadFullConfig(inputOpts) {\n  var _opts$assumptions;\n  const result = yield* (0, _partial.default)(inputOpts);\n  if (!result) {\n    return null;\n  }\n  const {\n    options,\n    context,\n    fileHandling\n  } = result;\n  if (fileHandling === \"ignored\") {\n    return null;\n  }\n  const optionDefaults = {};\n  const {\n    plugins,\n    presets\n  } = options;\n  if (!plugins || !presets) {\n    throw new Error(\"Assertion failure - plugins and presets exist\");\n  }\n  const presetContext = Object.assign({}, context, {\n    targets: options.targets\n  });\n  const toDescriptor = item => {\n    const desc = (0, _item.getItemDescriptor)(item);\n    if (!desc) {\n      throw new Error(\"Assertion failure - must be config item\");\n    }\n    return desc;\n  };\n  const presetsDescriptors = presets.map(toDescriptor);\n  const initialPluginsDescriptors = plugins.map(toDescriptor);\n  const pluginDescriptorsByPass = [[]];\n  const passes = [];\n  const externalDependencies = [];\n  const ignored = yield* enhanceError(context, function* recursePresetDescriptors(rawPresets, pluginDescriptorsPass) {\n    const presets = [];\n    for (let i = 0; i < rawPresets.length; i++) {\n      const descriptor = rawPresets[i];\n      if (descriptor.options !== false) {\n        try {\n          var preset = yield* loadPresetDescriptor(descriptor, presetContext);\n        } catch (e) {\n          if (e.code === \"BABEL_UNKNOWN_OPTION\") {\n            (0, _options.checkNoUnwrappedItemOptionPairs)(rawPresets, i, \"preset\", e);\n          }\n          throw e;\n        }\n        externalDependencies.push(preset.externalDependencies);\n        if (descriptor.ownPass) {\n          presets.push({\n            preset: preset.chain,\n            pass: []\n          });\n        } else {\n          presets.unshift({\n            preset: preset.chain,\n            pass: pluginDescriptorsPass\n          });\n        }\n      }\n    }\n    if (presets.length > 0) {\n      pluginDescriptorsByPass.splice(1, 0, ...presets.map(o => o.pass).filter(p => p !== pluginDescriptorsPass));\n      for (const {\n        preset,\n        pass\n      } of presets) {\n        if (!preset) return true;\n        pass.push(...preset.plugins);\n        const ignored = yield* recursePresetDescriptors(preset.presets, pass);\n        if (ignored) return true;\n        preset.options.forEach(opts => {\n          (0, _util.mergeOptions)(optionDefaults, opts);\n        });\n      }\n    }\n  })(presetsDescriptors, pluginDescriptorsByPass[0]);\n  if (ignored) return null;\n  const opts = optionDefaults;\n  (0, _util.mergeOptions)(opts, options);\n  const pluginContext = Object.assign({}, presetContext, {\n    assumptions: (_opts$assumptions = opts.assumptions) != null ? _opts$assumptions : {}\n  });\n  yield* enhanceError(context, function* loadPluginDescriptors() {\n    pluginDescriptorsByPass[0].unshift(...initialPluginsDescriptors);\n    for (const descs of pluginDescriptorsByPass) {\n      const pass = [];\n      passes.push(pass);\n      for (let i = 0; i < descs.length; i++) {\n        const descriptor = descs[i];\n        if (descriptor.options !== false) {\n          try {\n            var plugin = yield* loadPluginDescriptor(descriptor, pluginContext);\n          } catch (e) {\n            if (e.code === \"BABEL_UNKNOWN_PLUGIN_PROPERTY\") {\n              (0, _options.checkNoUnwrappedItemOptionPairs)(descs, i, \"plugin\", e);\n            }\n            throw e;\n          }\n          pass.push(plugin);\n          externalDependencies.push(plugin.externalDependencies);\n        }\n      }\n    }\n  })();\n  opts.plugins = passes[0];\n  opts.presets = passes.slice(1).filter(plugins => plugins.length > 0).map(plugins => ({\n    plugins\n  }));\n  opts.passPerPreset = opts.presets.length > 0;\n  return {\n    options: opts,\n    passes: passes,\n    externalDependencies: (0, _deepArray.finalize)(externalDependencies)\n  };\n});\nexports.default = _default;\nfunction enhanceError(context, fn) {\n  return function* (arg1, arg2) {\n    try {\n      return yield* fn(arg1, arg2);\n    } catch (e) {\n      if (!/^\\[BABEL\\]/.test(e.message)) {\n        var _context$filename;\n        e.message = `[BABEL] ${(_context$filename = context.filename) != null ? _context$filename : \"unknown file\"}: ${e.message}`;\n      }\n      throw e;\n    }\n  };\n}\nconst makeDescriptorLoader = apiFactory => (0, _caching.makeWeakCache)(function (_ref, cache) {\n  let {\n    value,\n    options,\n    dirname,\n    alias\n  } = _ref;\n  return function* () {\n    if (options === false) throw new Error(\"Assertion failure\");\n    options = options || {};\n    const externalDependencies = [];\n    let item = value;\n    if (typeof value === \"function\") {\n      const factory = (0, _async.maybeAsync)(value, `You appear to be using an async plugin/preset, but Babel has been called synchronously`);\n      const api = Object.assign({}, context, apiFactory(cache, externalDependencies));\n      try {\n        item = yield* factory(api, options, dirname);\n      } catch (e) {\n        if (alias) {\n          e.message += ` (While processing: ${JSON.stringify(alias)})`;\n        }\n        throw e;\n      }\n    }\n    if (!item || typeof item !== \"object\") {\n      throw new Error(\"Plugin/Preset did not return an object.\");\n    }\n    if ((0, _async.isThenable)(item)) {\n      yield* [];\n      throw new Error(`You appear to be using a promise as a plugin, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, ` + `you may need to upgrade your @babel/core version. ` + `As an alternative, you can prefix the promise with \"await\". ` + `(While processing: ${JSON.stringify(alias)})`);\n    }\n    if (externalDependencies.length > 0 && (!cache.configured() || cache.mode() === \"forever\")) {\n      let error = `A plugin/preset has external untracked dependencies ` + `(${externalDependencies[0]}), but the cache `;\n      if (!cache.configured()) {\n        error += `has not been configured to be invalidated when the external dependencies change. `;\n      } else {\n        error += ` has been configured to never be invalidated. `;\n      }\n      error += `Plugins/presets should configure their cache to be invalidated when the external ` + `dependencies change, for example using \\`api.cache.invalidate(() => ` + `statSync(filepath).mtimeMs)\\` or \\`api.cache.never()\\`\\n` + `(While processing: ${JSON.stringify(alias)})`;\n      throw new Error(error);\n    }\n    return {\n      value: item,\n      options,\n      dirname,\n      alias,\n      externalDependencies: (0, _deepArray.finalize)(externalDependencies)\n    };\n  }();\n});\nconst pluginDescriptorLoader = makeDescriptorLoader(_configApi.makePluginAPI);\nconst presetDescriptorLoader = makeDescriptorLoader(_configApi.makePresetAPI);\nconst instantiatePlugin = (0, _caching.makeWeakCache)(function (_ref2, cache) {\n  let {\n    value,\n    options,\n    dirname,\n    alias,\n    externalDependencies\n  } = _ref2;\n  return function* () {\n    const pluginObj = (0, _plugins.validatePluginObject)(value);\n    const plugin = Object.assign({}, pluginObj);\n    if (plugin.visitor) {\n      plugin.visitor = _traverse().default.explode(Object.assign({}, plugin.visitor));\n    }\n    if (plugin.inherits) {\n      const inheritsDescriptor = {\n        name: undefined,\n        alias: `${alias}$inherits`,\n        value: plugin.inherits,\n        options,\n        dirname\n      };\n      const inherits = yield* (0, _async.forwardAsync)(loadPluginDescriptor, run => {\n        return cache.invalidate(data => run(inheritsDescriptor, data));\n      });\n      plugin.pre = chain(inherits.pre, plugin.pre);\n      plugin.post = chain(inherits.post, plugin.post);\n      plugin.manipulateOptions = chain(inherits.manipulateOptions, plugin.manipulateOptions);\n      plugin.visitor = _traverse().default.visitors.merge([inherits.visitor || {}, plugin.visitor || {}]);\n      if (inherits.externalDependencies.length > 0) {\n        if (externalDependencies.length === 0) {\n          externalDependencies = inherits.externalDependencies;\n        } else {\n          externalDependencies = (0, _deepArray.finalize)([externalDependencies, inherits.externalDependencies]);\n        }\n      }\n    }\n    return new _plugin.default(plugin, options, alias, externalDependencies);\n  }();\n});\nfunction* loadPluginDescriptor(descriptor, context) {\n  if (descriptor.value instanceof _plugin.default) {\n    if (descriptor.options) {\n      throw new Error(\"Passed options to an existing Plugin instance will not work.\");\n    }\n    return descriptor.value;\n  }\n  return yield* instantiatePlugin(yield* pluginDescriptorLoader(descriptor, context), context);\n}\nconst needsFilename = val => val && typeof val !== \"function\";\nconst validateIfOptionNeedsFilename = (options, descriptor) => {\n  if (needsFilename(options.test) || needsFilename(options.include) || needsFilename(options.exclude)) {\n    const formattedPresetName = descriptor.name ? `\"${descriptor.name}\"` : \"/* your preset */\";\n    throw new _configError.default([`Preset ${formattedPresetName} requires a filename to be set when babel is called directly,`, `\\`\\`\\``, `babel.transformSync(code, { filename: 'file.ts', presets: [${formattedPresetName}] });`, `\\`\\`\\``, `See https://babeljs.io/docs/en/options#filename for more information.`].join(\"\\n\"));\n  }\n};\nconst validatePreset = (preset, context, descriptor) => {\n  if (!context.filename) {\n    const {\n      options\n    } = preset;\n    validateIfOptionNeedsFilename(options, descriptor);\n    if (options.overrides) {\n      options.overrides.forEach(overrideOptions => validateIfOptionNeedsFilename(overrideOptions, descriptor));\n    }\n  }\n};\nconst instantiatePreset = (0, _caching.makeWeakCacheSync)(_ref3 => {\n  let {\n    value,\n    dirname,\n    alias,\n    externalDependencies\n  } = _ref3;\n  return {\n    options: (0, _options.validate)(\"preset\", value),\n    alias,\n    dirname,\n    externalDependencies\n  };\n});\nfunction* loadPresetDescriptor(descriptor, context) {\n  const preset = instantiatePreset(yield* presetDescriptorLoader(descriptor, context));\n  validatePreset(preset, context, descriptor);\n  return {\n    chain: yield* (0, _configChain.buildPresetChain)(preset, context),\n    externalDependencies: preset.externalDependencies\n  };\n}\nfunction chain(a, b) {\n  const fns = [a, b].filter(Boolean);\n  if (fns.length <= 1) return fns[0];\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    for (const fn of fns) {\n      fn.apply(this, args);\n    }\n  };\n}\n0 && 0;","map":{"version":3,"mappings":"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","names":["_gensync","_traverse","gensync","loadFullConfig","inputOpts","result","options","context","fileHandling","optionDefaults","plugins","presets","Error","presetContext","targets","toDescriptor","item","desc","presetsDescriptors","map","initialPluginsDescriptors","pluginDescriptorsByPass","passes","externalDependencies","ignored","enhanceError","recursePresetDescriptors","rawPresets","pluginDescriptorsPass","i","length","descriptor","preset","loadPresetDescriptor","e","code","push","ownPass","chain","pass","unshift","splice","o","filter","p","forEach","opts","pluginContext","assumptions","loadPluginDescriptors","descs","plugin","loadPluginDescriptor","slice","passPerPreset","exports","fn","arg1","arg2","test","message","filename","makeDescriptorLoader","apiFactory","cache","value","dirname","alias","factory","api","JSON","stringify","configured","mode","error","pluginDescriptorLoader","makePluginAPI","presetDescriptorLoader","makePresetAPI","instantiatePlugin","pluginObj","visitor","traverse","explode","inherits","inheritsDescriptor","name","undefined","run","invalidate","data","pre","post","manipulateOptions","visitors","merge","Plugin","needsFilename","val","validateIfOptionNeedsFilename","include","exclude","formattedPresetName","ConfigError","join","validatePreset","overrides","overrideOptions","instantiatePreset","a","b","fns","Boolean","args","apply"],"sources":["/Users/elahehaslani/Work/Sample-Project/ticket-booking/ticket-booking/node_modules/@babel/core/src/config/full.ts"],"sourcesContent":["import gensync, { type Handler } from \"gensync\";\nimport { forwardAsync, maybeAsync, isThenable } from \"../gensync-utils/async\";\n\nimport { mergeOptions } from \"./util\";\nimport * as context from \"../index\";\nimport Plugin from \"./plugin\";\nimport { getItemDescriptor } from \"./item\";\nimport { buildPresetChain } from \"./config-chain\";\nimport { finalize as freezeDeepArray } from \"./helpers/deep-array\";\nimport type { DeepArray, ReadonlyDeepArray } from \"./helpers/deep-array\";\nimport type {\n  ConfigContext,\n  ConfigChain,\n  PresetInstance,\n} from \"./config-chain\";\nimport type { UnloadedDescriptor } from \"./config-descriptors\";\nimport traverse from \"@babel/traverse\";\nimport { makeWeakCache, makeWeakCacheSync } from \"./caching\";\nimport type { CacheConfigurator } from \"./caching\";\nimport {\n  validate,\n  checkNoUnwrappedItemOptionPairs,\n} from \"./validation/options\";\nimport type { PluginItem } from \"./validation/options\";\nimport { validatePluginObject } from \"./validation/plugins\";\nimport { makePluginAPI, makePresetAPI } from \"./helpers/config-api\";\nimport type { PluginAPI, PresetAPI } from \"./helpers/config-api\";\n\nimport loadPrivatePartialConfig from \"./partial\";\nimport type { ValidatedOptions } from \"./validation/options\";\n\nimport type * as Context from \"./cache-contexts\";\nimport ConfigError from \"../errors/config-error\";\n\ntype LoadedDescriptor = {\n  value: {};\n  options: {};\n  dirname: string;\n  alias: string;\n  externalDependencies: ReadonlyDeepArray<string>;\n};\n\nexport type { InputOptions } from \"./validation/options\";\n\nexport type ResolvedConfig = {\n  options: any;\n  passes: PluginPasses;\n  externalDependencies: ReadonlyDeepArray<string>;\n};\n\nexport type { Plugin };\nexport type PluginPassList = Array<Plugin>;\nexport type PluginPasses = Array<PluginPassList>;\n\nexport default gensync(function* loadFullConfig(\n  inputOpts: unknown,\n): Handler<ResolvedConfig | null> {\n  const result = yield* loadPrivatePartialConfig(inputOpts);\n  if (!result) {\n    return null;\n  }\n  const { options, context, fileHandling } = result;\n\n  if (fileHandling === \"ignored\") {\n    return null;\n  }\n\n  const optionDefaults = {};\n\n  const { plugins, presets } = options;\n\n  if (!plugins || !presets) {\n    throw new Error(\"Assertion failure - plugins and presets exist\");\n  }\n\n  const presetContext: Context.FullPreset = {\n    ...context,\n    targets: options.targets,\n  };\n\n  const toDescriptor = (item: PluginItem) => {\n    const desc = getItemDescriptor(item);\n    if (!desc) {\n      throw new Error(\"Assertion failure - must be config item\");\n    }\n\n    return desc;\n  };\n\n  const presetsDescriptors = presets.map(toDescriptor);\n  const initialPluginsDescriptors = plugins.map(toDescriptor);\n  const pluginDescriptorsByPass: Array<Array<UnloadedDescriptor>> = [[]];\n  const passes: Array<Array<Plugin>> = [];\n\n  const externalDependencies: DeepArray<string> = [];\n\n  const ignored = yield* enhanceError(\n    context,\n    function* recursePresetDescriptors(\n      rawPresets: Array<UnloadedDescriptor>,\n      pluginDescriptorsPass: Array<UnloadedDescriptor>,\n    ): Handler<true | void> {\n      const presets: Array<{\n        preset: ConfigChain | null;\n        pass: Array<UnloadedDescriptor>;\n      }> = [];\n\n      for (let i = 0; i < rawPresets.length; i++) {\n        const descriptor = rawPresets[i];\n        if (descriptor.options !== false) {\n          try {\n            // eslint-disable-next-line no-var\n            var preset = yield* loadPresetDescriptor(descriptor, presetContext);\n          } catch (e) {\n            if (e.code === \"BABEL_UNKNOWN_OPTION\") {\n              checkNoUnwrappedItemOptionPairs(rawPresets, i, \"preset\", e);\n            }\n            throw e;\n          }\n\n          externalDependencies.push(preset.externalDependencies);\n\n          // Presets normally run in reverse order, but if they\n          // have their own pass they run after the presets\n          // in the previous pass.\n          if (descriptor.ownPass) {\n            presets.push({ preset: preset.chain, pass: [] });\n          } else {\n            presets.unshift({\n              preset: preset.chain,\n              pass: pluginDescriptorsPass,\n            });\n          }\n        }\n      }\n\n      // resolve presets\n      if (presets.length > 0) {\n        // The passes are created in the same order as the preset list, but are inserted before any\n        // existing additional passes.\n        pluginDescriptorsByPass.splice(\n          1,\n          0,\n          ...presets.map(o => o.pass).filter(p => p !== pluginDescriptorsPass),\n        );\n\n        for (const { preset, pass } of presets) {\n          if (!preset) return true;\n\n          pass.push(...preset.plugins);\n\n          const ignored = yield* recursePresetDescriptors(preset.presets, pass);\n          if (ignored) return true;\n\n          preset.options.forEach(opts => {\n            mergeOptions(optionDefaults, opts);\n          });\n        }\n      }\n    },\n  )(presetsDescriptors, pluginDescriptorsByPass[0]);\n\n  if (ignored) return null;\n\n  const opts: any = optionDefaults;\n  mergeOptions(opts, options);\n\n  const pluginContext: Context.FullPlugin = {\n    ...presetContext,\n    assumptions: opts.assumptions ?? {},\n  };\n\n  yield* enhanceError(context, function* loadPluginDescriptors() {\n    pluginDescriptorsByPass[0].unshift(...initialPluginsDescriptors);\n\n    for (const descs of pluginDescriptorsByPass) {\n      const pass: Plugin[] = [];\n      passes.push(pass);\n\n      for (let i = 0; i < descs.length; i++) {\n        const descriptor: UnloadedDescriptor = descs[i];\n        if (descriptor.options !== false) {\n          try {\n            // eslint-disable-next-line no-var\n            var plugin = yield* loadPluginDescriptor(descriptor, pluginContext);\n          } catch (e) {\n            if (e.code === \"BABEL_UNKNOWN_PLUGIN_PROPERTY\") {\n              // print special message for `plugins: [\"@babel/foo\", { foo: \"option\" }]`\n              checkNoUnwrappedItemOptionPairs(descs, i, \"plugin\", e);\n            }\n            throw e;\n          }\n          pass.push(plugin);\n\n          externalDependencies.push(plugin.externalDependencies);\n        }\n      }\n    }\n  })();\n\n  opts.plugins = passes[0];\n  opts.presets = passes\n    .slice(1)\n    .filter(plugins => plugins.length > 0)\n    .map(plugins => ({ plugins }));\n  opts.passPerPreset = opts.presets.length > 0;\n\n  return {\n    options: opts,\n    passes: passes,\n    externalDependencies: freezeDeepArray(externalDependencies),\n  };\n});\n\nfunction enhanceError<T extends Function>(context: ConfigContext, fn: T): T {\n  return function* (arg1: unknown, arg2: unknown) {\n    try {\n      return yield* fn(arg1, arg2);\n    } catch (e) {\n      // There are a few case where thrown errors will try to annotate themselves multiple times, so\n      // to keep things simple we just bail out if re-wrapping the message.\n      if (!/^\\[BABEL\\]/.test(e.message)) {\n        e.message = `[BABEL] ${context.filename ?? \"unknown file\"}: ${\n          e.message\n        }`;\n      }\n\n      throw e;\n    }\n  } as any;\n}\n\n/**\n * Load a generic plugin/preset from the given descriptor loaded from the config object.\n */\nconst makeDescriptorLoader = <Context, API>(\n  apiFactory: (\n    cache: CacheConfigurator<Context>,\n    externalDependencies: Array<string>,\n  ) => API,\n) =>\n  makeWeakCache(function* (\n    { value, options, dirname, alias }: UnloadedDescriptor,\n    cache: CacheConfigurator<Context>,\n  ): Handler<LoadedDescriptor> {\n    // Disabled presets should already have been filtered out\n    if (options === false) throw new Error(\"Assertion failure\");\n\n    options = options || {};\n\n    const externalDependencies: Array<string> = [];\n\n    let item = value;\n    if (typeof value === \"function\") {\n      const factory = maybeAsync(\n        value,\n        `You appear to be using an async plugin/preset, but Babel has been called synchronously`,\n      );\n\n      const api = {\n        ...context,\n        ...apiFactory(cache, externalDependencies),\n      };\n      try {\n        item = yield* factory(api, options, dirname);\n      } catch (e) {\n        if (alias) {\n          e.message += ` (While processing: ${JSON.stringify(alias)})`;\n        }\n        throw e;\n      }\n    }\n\n    if (!item || typeof item !== \"object\") {\n      throw new Error(\"Plugin/Preset did not return an object.\");\n    }\n\n    if (isThenable(item)) {\n      // @ts-expect-error - if we want to support async plugins\n      yield* [];\n\n      throw new Error(\n        `You appear to be using a promise as a plugin, ` +\n          `which your current version of Babel does not support. ` +\n          `If you're using a published plugin, ` +\n          `you may need to upgrade your @babel/core version. ` +\n          `As an alternative, you can prefix the promise with \"await\". ` +\n          `(While processing: ${JSON.stringify(alias)})`,\n      );\n    }\n\n    if (\n      externalDependencies.length > 0 &&\n      (!cache.configured() || cache.mode() === \"forever\")\n    ) {\n      let error =\n        `A plugin/preset has external untracked dependencies ` +\n        `(${externalDependencies[0]}), but the cache `;\n      if (!cache.configured()) {\n        error += `has not been configured to be invalidated when the external dependencies change. `;\n      } else {\n        error += ` has been configured to never be invalidated. `;\n      }\n      error +=\n        `Plugins/presets should configure their cache to be invalidated when the external ` +\n        `dependencies change, for example using \\`api.cache.invalidate(() => ` +\n        `statSync(filepath).mtimeMs)\\` or \\`api.cache.never()\\`\\n` +\n        `(While processing: ${JSON.stringify(alias)})`;\n\n      throw new Error(error);\n    }\n\n    return {\n      value: item,\n      options,\n      dirname,\n      alias,\n      externalDependencies: freezeDeepArray(externalDependencies),\n    };\n  });\n\nconst pluginDescriptorLoader = makeDescriptorLoader<\n  Context.SimplePlugin,\n  PluginAPI\n>(makePluginAPI);\nconst presetDescriptorLoader = makeDescriptorLoader<\n  Context.SimplePreset,\n  PresetAPI\n>(makePresetAPI);\n\nconst instantiatePlugin = makeWeakCache(function* (\n  { value, options, dirname, alias, externalDependencies }: LoadedDescriptor,\n  cache: CacheConfigurator<Context.SimplePlugin>,\n): Handler<Plugin> {\n  const pluginObj = validatePluginObject(value);\n\n  const plugin = {\n    ...pluginObj,\n  };\n  if (plugin.visitor) {\n    plugin.visitor = traverse.explode({\n      ...plugin.visitor,\n    });\n  }\n\n  if (plugin.inherits) {\n    const inheritsDescriptor: UnloadedDescriptor = {\n      name: undefined,\n      alias: `${alias}$inherits`,\n      value: plugin.inherits,\n      options,\n      dirname,\n    };\n\n    const inherits = yield* forwardAsync(loadPluginDescriptor, run => {\n      // If the inherited plugin changes, reinstantiate this plugin.\n      return cache.invalidate(data => run(inheritsDescriptor, data));\n    });\n\n    plugin.pre = chain(inherits.pre, plugin.pre);\n    plugin.post = chain(inherits.post, plugin.post);\n    plugin.manipulateOptions = chain(\n      inherits.manipulateOptions,\n      plugin.manipulateOptions,\n    );\n    plugin.visitor = traverse.visitors.merge([\n      inherits.visitor || {},\n      plugin.visitor || {},\n    ]);\n\n    if (inherits.externalDependencies.length > 0) {\n      if (externalDependencies.length === 0) {\n        externalDependencies = inherits.externalDependencies;\n      } else {\n        externalDependencies = freezeDeepArray([\n          externalDependencies,\n          inherits.externalDependencies,\n        ]);\n      }\n    }\n  }\n\n  return new Plugin(plugin, options, alias, externalDependencies);\n});\n\n/**\n * Instantiate a plugin for the given descriptor, returning the plugin/options pair.\n */\nfunction* loadPluginDescriptor(\n  descriptor: UnloadedDescriptor,\n  context: Context.SimplePlugin,\n): Handler<Plugin> {\n  if (descriptor.value instanceof Plugin) {\n    if (descriptor.options) {\n      throw new Error(\n        \"Passed options to an existing Plugin instance will not work.\",\n      );\n    }\n\n    return descriptor.value;\n  }\n\n  return yield* instantiatePlugin(\n    yield* pluginDescriptorLoader(descriptor, context),\n    context,\n  );\n}\n\nconst needsFilename = (val: unknown) => val && typeof val !== \"function\";\n\nconst validateIfOptionNeedsFilename = (\n  options: ValidatedOptions,\n  descriptor: UnloadedDescriptor,\n): void => {\n  if (\n    needsFilename(options.test) ||\n    needsFilename(options.include) ||\n    needsFilename(options.exclude)\n  ) {\n    const formattedPresetName = descriptor.name\n      ? `\"${descriptor.name}\"`\n      : \"/* your preset */\";\n    throw new ConfigError(\n      [\n        `Preset ${formattedPresetName} requires a filename to be set when babel is called directly,`,\n        `\\`\\`\\``,\n        `babel.transformSync(code, { filename: 'file.ts', presets: [${formattedPresetName}] });`,\n        `\\`\\`\\``,\n        `See https://babeljs.io/docs/en/options#filename for more information.`,\n      ].join(\"\\n\"),\n    );\n  }\n};\n\nconst validatePreset = (\n  preset: PresetInstance,\n  context: ConfigContext,\n  descriptor: UnloadedDescriptor,\n): void => {\n  if (!context.filename) {\n    const { options } = preset;\n    validateIfOptionNeedsFilename(options, descriptor);\n    if (options.overrides) {\n      options.overrides.forEach(overrideOptions =>\n        validateIfOptionNeedsFilename(overrideOptions, descriptor),\n      );\n    }\n  }\n};\n\nconst instantiatePreset = makeWeakCacheSync(\n  ({\n    value,\n    dirname,\n    alias,\n    externalDependencies,\n  }: LoadedDescriptor): PresetInstance => {\n    return {\n      options: validate(\"preset\", value),\n      alias,\n      dirname,\n      externalDependencies,\n    };\n  },\n);\n\n/**\n * Generate a config object that will act as the root of a new nested config.\n */\nfunction* loadPresetDescriptor(\n  descriptor: UnloadedDescriptor,\n  context: Context.FullPreset,\n): Handler<{\n  chain: ConfigChain | null;\n  externalDependencies: ReadonlyDeepArray<string>;\n}> {\n  const preset = instantiatePreset(\n    yield* presetDescriptorLoader(descriptor, context),\n  );\n  validatePreset(preset, context, descriptor);\n  return {\n    chain: yield* buildPresetChain(preset, context),\n    externalDependencies: preset.externalDependencies,\n  };\n}\n\nfunction chain<Args extends any[]>(\n  a: undefined | ((...args: Args) => void),\n  b: undefined | ((...args: Args) => void),\n) {\n  const fns = [a, b].filter(Boolean);\n  if (fns.length <= 1) return fns[0];\n\n  return function (this: unknown, ...args: unknown[]) {\n    for (const fn of fns) {\n      fn.apply(this, args);\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}