{"ast":null,"code":"import { objectToSearchString } from \"./objectToSearchString\";\nimport { searchStringToObject } from \".\";\nconst JSON_SAFE_CHARS = `{}[],\":`.split(\"\").map(d => [d, encodeURIComponent(d)]);\nfunction getHrefFromLocation(location, search) {\n  let href = search;\n  if (location.href) {\n    try {\n      const url = new URL(location.href);\n      href = `${url.origin}${url.pathname}${search}`;\n    } catch (e) {\n      href = \"\";\n    }\n  }\n  return href;\n}\nfunction transformSearchStringJsonSafe(searchString) {\n  let str = searchString;\n  for (let [char, code] of JSON_SAFE_CHARS) {\n    str = str.replace(new RegExp(\"\\\\\" + code, \"g\"), char);\n  }\n  return str;\n}\nfunction updateLocation(encodedQuery, location) {\n  let objectToSearchStringFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : objectToSearchString;\n  let encodedSearchString = objectToSearchStringFn(encodedQuery);\n  const search = encodedSearchString.length ? `?${encodedSearchString}` : \"\";\n  const newLocation = {\n    ...location,\n    key: `${Date.now()}`,\n    href: getHrefFromLocation(location, search),\n    search,\n    query: encodedQuery\n  };\n  return newLocation;\n}\nfunction updateInLocation(encodedQueryReplacements, location) {\n  let objectToSearchStringFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : objectToSearchString;\n  let searchStringToObjectFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : searchStringToObject;\n  const currQuery = searchStringToObjectFn(location.search);\n  const newQuery = {\n    ...currQuery,\n    ...encodedQueryReplacements\n  };\n  return updateLocation(newQuery, location, objectToSearchStringFn);\n}\nexport { transformSearchStringJsonSafe, updateInLocation, updateLocation };","map":{"version":3,"mappings":"AACA,SAASA,4BAA4B;AACrC,SAASC,4BAA4B;AAMrC,MAAMC,kBAAkB,UACrBC,MAAM,EAAE,EACRC,IAAKC,KAAM,CAACA,GAAGC,mBAAmBD,CAAC,CAAC,CAAC;AAExC,SAASE,oBAAoBC,UAAoBC,QAAwB;EAEvE,IAAIC,OAAeD;EAEnB,IAAID,SAASE,MAAM;IAGjB,IAAI;MACF,MAAMC,MAAM,IAAIC,IAAIJ,SAASE,IAAI;MACjCA,OAAO,GAAGC,IAAIE,SAASF,IAAIG,WAAWL;IACxC,SAASM,GAAP;MACAL,OAAO;IACT;EACF;EAEA,OAAOA;AACT;AAEO,SAASM,8BAA8BC,cAA8B;EAC1E,IAAIC,MAAMD;EACV,SAAS,CAACE,MAAMC,IAAI,KAAKlB,iBAAiB;IACxCgB,MAAMA,IAAIG,QAAQ,IAAIC,OAAO,OAAOF,MAAM,GAAG,GAAGD,IAAI;EACtD;EACA,OAAOD;AACT;AAMO,SAASK,eACdC,cACAhB,UAEU;EAAA,IADViB,6FAAyBzB;EAEzB,IAAI0B,sBAAsBD,uBAAuBD,YAAY;EAE7D,MAAMf,SAASiB,oBAAoBC,SAAS,IAAID,wBAAwB;EAExE,MAAME,cAGF;IACF,GAAGpB;IACHqB,KAAK,GAAGC,KAAKC,KAAI;IACjBrB,MAAMH,oBAAoBC,UAAUC,MAAM;IAC1CA;IACAuB,OAAOR;EACT;EAEA,OAAOI;AACT;AAMO,SAASK,iBACdC,0BACA1B,UAGU;EAAA,IAFViB,6FAAyBzB;EAAA,IACzBmC,6FAAyBlC;EAIzB,MAAMmC,YAAYD,uBAAuB3B,SAASC,MAAM;EAExD,MAAM4B,WAAW;IACf,GAAGD;IACH,GAAGF;EACL;EAEA,OAAOX,eAAec,UAAU7B,UAAUiB,sBAAsB;AAClE","names":["objectToSearchString","searchStringToObject","JSON_SAFE_CHARS","split","map","d","encodeURIComponent","getHrefFromLocation","location","search","href","url","URL","origin","pathname","e","transformSearchStringJsonSafe","searchString","str","char","code","replace","RegExp","updateLocation","encodedQuery","objectToSearchStringFn","encodedSearchString","length","newLocation","key","Date","now","query","updateInLocation","encodedQueryReplacements","searchStringToObjectFn","currQuery","newQuery"],"sources":["/Users/elahehaslani/Work/Sample-Project/ticket-booking/ticket-booking/node_modules/serialize-query-params/src/updateLocation.ts"],"sourcesContent":["import { EncodedQuery } from './types';\nimport { objectToSearchString } from './objectToSearchString';\nimport { searchStringToObject } from '.';\n\n/**\n * An example of a transformSearchString function that undoes encoding of\n * common JSON characters that are technically allowed in URLs.\n */\nconst JSON_SAFE_CHARS = `{}[],\":`\n  .split('')\n  .map((d) => [d, encodeURIComponent(d)]);\n\nfunction getHrefFromLocation(location: Location, search: string): string {\n  // https://developer.mozilla.org/en-US/docs/Web/API/URL/URL\n  let href: string = search;\n\n  if (location.href) {\n      // TODO - implement base option if location.href is relative\n      //  see https://developer.mozilla.org/en-US/docs/Web/API/URL/URL#syntax\n    try {\n      const url = new URL(location.href);\n      href = `${url.origin}${url.pathname}${search}`;\n    } catch (e) {\n      href = '';\n    }\n  }\n\n  return href;\n}\n\nexport function transformSearchStringJsonSafe(searchString: string): string {\n  let str = searchString;\n  for (let [char, code] of JSON_SAFE_CHARS) {\n    str = str.replace(new RegExp('\\\\' + code, 'g'), char);\n  }\n  return str;\n}\n\n/**\n * Update a location, wiping out parameters not included in encodedQuery\n * If a param is set to undefined it will be removed from the URL.\n */\nexport function updateLocation(\n  encodedQuery: EncodedQuery,\n  location: Location,\n  objectToSearchStringFn = objectToSearchString\n): Location {\n  let encodedSearchString = objectToSearchStringFn(encodedQuery);\n\n  const search = encodedSearchString.length ? `?${encodedSearchString}` : '';\n\n  const newLocation: Location & {\n    key: string;\n    query: EncodedQuery;\n  } = {\n    ...location,\n    key: `${Date.now()}`, // needed for some routers (e.g. react-router)\n    href: getHrefFromLocation(location, search),\n    search,\n    query: encodedQuery, // needed for some routers (e.g. found)\n  };\n\n  return newLocation;\n}\n\n/**\n * Update a location while retaining existing parameters.\n * If a param is set to undefined it will be removed from the URL.\n */\nexport function updateInLocation(\n  encodedQueryReplacements: EncodedQuery,\n  location: Location,\n  objectToSearchStringFn = objectToSearchString,\n  searchStringToObjectFn = searchStringToObject\n): Location {\n  // explicitly avoid parsing numbers to ensure the\n  // return type has the same shape as EncodeQuery\n  const currQuery = searchStringToObjectFn(location.search);\n\n  const newQuery = {\n    ...currQuery,\n    ...encodedQueryReplacements,\n  };\n\n  return updateLocation(newQuery, location, objectToSearchStringFn);\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}