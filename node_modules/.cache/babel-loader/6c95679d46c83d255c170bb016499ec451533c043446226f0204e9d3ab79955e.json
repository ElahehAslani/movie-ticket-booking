{"ast":null,"code":"import { encodeQueryParams } from \"serialize-query-params\";\nimport { decodedParamCache } from \"./decodedParamCache\";\nimport { extendParamConfigForKeys } from \"./inheritedParams\";\nimport { getLatestDecodedValues } from \"./latestValues\";\nimport { memoSearchStringToObject } from \"./memoSearchStringToObject\";\nimport { removeDefaults } from \"./removeDefaults\";\nimport { applyUrlNames } from \"./urlName\";\nfunction getUpdatedSearchString(_ref) {\n  let {\n    changes,\n    updateType,\n    currentSearchString,\n    paramConfigMap: baseParamConfigMap,\n    options\n  } = _ref;\n  const {\n    searchStringToObject,\n    objectToSearchString\n  } = options;\n  if (updateType == null) updateType = options.updateType;\n  let encodedChanges;\n  const parsedParams = memoSearchStringToObject(searchStringToObject, currentSearchString);\n  const paramConfigMap = extendParamConfigForKeys(baseParamConfigMap, Object.keys(changes), options.params);\n  let changesToUse;\n  if (typeof changes === \"function\") {\n    const latestValues = getLatestDecodedValues(parsedParams, paramConfigMap, decodedParamCache);\n    changesToUse = changes(latestValues);\n  } else {\n    changesToUse = changes;\n  }\n  encodedChanges = encodeQueryParams(paramConfigMap, changesToUse);\n  if (options.removeDefaultsFromUrl) {\n    removeDefaults(encodedChanges, paramConfigMap);\n  }\n  encodedChanges = applyUrlNames(encodedChanges, paramConfigMap);\n  let newSearchString;\n  if (updateType === \"push\" || updateType === \"replace\") {\n    newSearchString = objectToSearchString(encodedChanges);\n  } else {\n    newSearchString = objectToSearchString({\n      ...parsedParams,\n      ...encodedChanges\n    });\n  }\n  if ((newSearchString == null ? void 0 : newSearchString.length) && newSearchString[0] !== \"?\") {\n    newSearchString = `?${newSearchString}`;\n  }\n  return newSearchString != null ? newSearchString : \"\";\n}\nfunction updateSearchString(_ref2) {\n  let {\n    searchString,\n    adapter,\n    navigate,\n    updateType\n  } = _ref2;\n  const currentLocation = adapter.location;\n  const newLocation = {\n    ...currentLocation,\n    search: searchString\n  };\n  if (navigate) {\n    if (typeof updateType === \"string\" && updateType.startsWith(\"replace\")) {\n      adapter.replace(newLocation);\n    } else {\n      adapter.push(newLocation);\n    }\n  }\n}\nconst immediateTask = task => task();\nconst timeoutTask = task => setTimeout(() => task(), 0);\nconst updateQueue = [];\nfunction enqueueUpdate(args) {\n  let {\n    immediate\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  updateQueue.push(args);\n  let scheduleTask = immediate ? immediateTask : timeoutTask;\n  if (updateQueue.length === 1) {\n    scheduleTask(() => {\n      const updates = updateQueue.slice();\n      updateQueue.length = 0;\n      const initialSearchString = updates[0].currentSearchString;\n      let searchString;\n      for (let i = 0; i < updates.length; ++i) {\n        const modifiedUpdate = i === 0 ? updates[i] : {\n          ...updates[i],\n          currentSearchString: searchString\n        };\n        searchString = getUpdatedSearchString(modifiedUpdate);\n      }\n      if (args.options.skipUpdateWhenNoChange && searchString === initialSearchString) {\n        return;\n      }\n      updateSearchString({\n        searchString: searchString != null ? searchString : \"\",\n        adapter: updates[updates.length - 1].adapter,\n        navigate: true,\n        updateType: updates[updates.length - 1].updateType\n      });\n    });\n  }\n}\nexport { enqueueUpdate, getUpdatedSearchString, updateSearchString };","map":{"version":3,"mappings":"AAAA,SAEEA,yBAEK;AACP,SAASC,yBAAyB;AAClC,SAASC,gCAAgC;AACzC,SAASC,8BAA8B;AACvC,SAASC,gCAAgC;AAEzC,SAASC,sBAAsB;AAE/B,SAASC,qBAAqB;AAYvB,SAASC,6BAYL;EAAA,IAZ4B;IACrCC;IACAC;IACAC;IACAC,gBAAgBC;IAChBC;EACF;EAOE,MAAM;IAAEC;IAAsBC;EAAqB,IAAIF;EACvD,IAAIJ,cAAc,MAAMA,aAAaI,QAAQJ;EAE7C,IAAIO;EACJ,MAAMC,eAAeb,yBACnBU,sBACAJ,oBACF;EAIA,MAAMC,iBAAiBT,yBACrBU,oBACAM,OAAOC,KAAKX,OAAO,GACnBK,QAAQO,OACV;EAIA,IAAIC;EAGJ,IAAI,OAAOb,YAAY,YAAY;IACjC,MAAMc,eAAenB,uBACnBc,cACAN,gBACAV,kBACF;IAEAoB,eAAgBb,QAAqBc,YAAY;EACnD,OAAO;IAELD,eAAeb;EACjB;EAEAQ,iBAAiBhB,kBAAkBW,gBAAgBU,YAAY;EAG/D,IAAIR,QAAQU,uBAAuB;IACjClB,eAAeW,gBAAgBL,cAAc;EAC/C;EAGAK,iBAAiBV,cAAcU,gBAAgBL,cAAc;EAE7D,IAAIa;EACJ,IAAIf,eAAe,UAAUA,eAAe,WAAW;IACrDe,kBAAkBT,qBAAqBC,cAAc;EACvD,OAAO;IACLQ,kBAAkBT,qBAAqB;MACrC,GAAGE;MACH,GAAGD;IACL,CAAC;EACH;EAEA,KAAIQ,mDAAiBC,WAAUD,gBAAgB,OAAO,KAAK;IACxDA,kBAA0B,IAAIA;EACjC;EAEA,OAAOA,4CAAmB;AAC5B;AAMO,SAASE,0BAUb;EAAA,IAVgC;IACjCC;IACAC;IACAC;IACApB;EACF;EAME,MAAMqB,kBAAkBF,QAAQG;EAGhC,MAAMC,cAA+B;IACnC,GAAGF;IACHG,QAAQN;EACV;EAEA,IAAIE,UAAU;IAGZ,IAAI,OAAOpB,eAAe,YAAYA,WAAWyB,WAAW,SAAS,GAAG;MACtEN,QAAQO,QAAQH,WAAW;IAC7B,OAAO;MACLJ,QAAQQ,KAAKJ,WAAW;IAC1B;EACF;AACF;AAMA,MAAMK,gBAAiBC,QAAmBA,MAAK;AAC/C,MAAMC,cAAeD,QAAmBE,WAAW,MAAMF,MAAK,EAAG,CAAC;AAGlE,MAAMG,cAA4B,EAAC;AAK5B,SAASC,cACdC,MAEA;EAAA,IADA;IAAEC;EAAU,wEAA6B,CAAC;EAE1CH,YAAYL,KAAKO,IAAI;EACrB,IAAIE,eAAeD,YAAYP,gBAAgBE;EAE/C,IAAIE,YAAYhB,WAAW,GAAG;IAC5BoB,aAAa,MAAM;MACjB,MAAMC,UAAUL,YAAYM,OAAM;MAClCN,YAAYhB,SAAS;MACrB,MAAMuB,sBAAsBF,QAAQ,GAAGpC;MAEvC,IAAIiB;MACJ,SAASsB,IAAI,GAAGA,IAAIH,QAAQrB,QAAQ,EAAEwB,GAAG;QACvC,MAAMC,iBACJD,MAAM,IACFH,QAAQG,KACR;UAAE,GAAGH,QAAQG;UAAIvC,qBAAqBiB;QAAc;QAC1DA,eAAepB,uBAAuB2C,cAAc;MACtD;MAGA,IACEP,KAAK9B,QAAQsC,0BACbxB,iBAAiBqB,qBACjB;QACA;MACF;MAEAtB,mBAAmB;QACjBC,cAAcA,sCAAgB;QAC9BC,SAASkB,QAAQA,QAAQrB,SAAS,GAAGG;QACrCC,UAAU;QACVpB,YAAYqC,QAAQA,QAAQrB,SAAS,GAAGhB;MAC1C,CAAC;IACH,CAAC;EACH;AACF","names":["encodeQueryParams","decodedParamCache","extendParamConfigForKeys","getLatestDecodedValues","memoSearchStringToObject","removeDefaults","applyUrlNames","getUpdatedSearchString","changes","updateType","currentSearchString","paramConfigMap","baseParamConfigMap","options","searchStringToObject","objectToSearchString","encodedChanges","parsedParams","Object","keys","params","changesToUse","latestValues","removeDefaultsFromUrl","newSearchString","length","updateSearchString","searchString","adapter","navigate","currentLocation","location","newLocation","search","startsWith","replace","push","immediateTask","task","timeoutTask","setTimeout","updateQueue","enqueueUpdate","args","immediate","scheduleTask","updates","slice","initialSearchString","i","modifiedUpdate","skipUpdateWhenNoChange"],"sources":["/Users/elahehaslani/Documents/GitHub/movie-ticket-booking/node_modules/use-query-params/src/updateSearchString.ts"],"sourcesContent":["import {\n  DecodedValueMap,\n  encodeQueryParams,\n  QueryParamConfigMap,\n} from 'serialize-query-params';\nimport { decodedParamCache } from './decodedParamCache';\nimport { extendParamConfigForKeys } from './inheritedParams';\nimport { getLatestDecodedValues } from './latestValues';\nimport { memoSearchStringToObject } from './memoSearchStringToObject';\nimport { QueryParamOptionsWithRequired } from './options';\nimport { removeDefaults } from './removeDefaults';\nimport { PartialLocation, QueryParamAdapter, UrlUpdateType } from './types';\nimport { applyUrlNames } from './urlName';\n\n// for multiple param config\ntype ChangesType<DecodedValueMapType> =\n  | Partial<DecodedValueMapType>\n  | ((latestValues: DecodedValueMapType) => Partial<DecodedValueMapType>);\n\n/**\n * Given a ?foo=1&bar=2 and { bar: 3, baz: true } produce ?foo=1&bar=3&baz=1\n * or similar, depending on updateType. The result will be prefixed with \"?\"\n * or just be the empty string.\n */\nexport function getUpdatedSearchString({\n  changes,\n  updateType,\n  currentSearchString,\n  paramConfigMap: baseParamConfigMap,\n  options,\n}: {\n  changes: ChangesType<DecodedValueMap<any>>;\n  updateType?: UrlUpdateType;\n  currentSearchString: string;\n  paramConfigMap: QueryParamConfigMap;\n  options: QueryParamOptionsWithRequired;\n}): string {\n  const { searchStringToObject, objectToSearchString } = options;\n  if (updateType == null) updateType = options.updateType;\n\n  let encodedChanges;\n  const parsedParams = memoSearchStringToObject(\n    searchStringToObject,\n    currentSearchString\n  );\n\n  // see if we have unconfigured params in the changes that we can\n  // inherit to expand our config map instead of just using strings\n  const paramConfigMap = extendParamConfigForKeys(\n    baseParamConfigMap,\n    Object.keys(changes),\n    options.params\n  );\n\n  // update changes prior to encoding to handle removing defaults\n  // getting latest values when functional update\n  let changesToUse: Partial<DecodedValueMap<any>>;\n\n  // functional updates here get the latest values\n  if (typeof changes === 'function') {\n    const latestValues = getLatestDecodedValues(\n      parsedParams,\n      paramConfigMap,\n      decodedParamCache\n    );\n\n    changesToUse = (changes as Function)(latestValues);\n  } else {\n    // simple update here\n    changesToUse = changes;\n  }\n\n  encodedChanges = encodeQueryParams(paramConfigMap, changesToUse);\n\n  // remove defaults\n  if (options.removeDefaultsFromUrl) {\n    removeDefaults(encodedChanges, paramConfigMap);\n  }\n\n  // interpret urlNames\n  encodedChanges = applyUrlNames(encodedChanges, paramConfigMap);\n\n  let newSearchString: string;\n  if (updateType === 'push' || updateType === 'replace') {\n    newSearchString = objectToSearchString(encodedChanges);\n  } else {\n    newSearchString = objectToSearchString({\n      ...parsedParams,\n      ...encodedChanges,\n    });\n  }\n\n  if (newSearchString?.length && newSearchString[0] !== '?') {\n    (newSearchString as any) = `?${newSearchString}`;\n  }\n\n  return newSearchString ?? '';\n}\n\n/**\n * uses an adapter to update a location object and optionally\n * navigate based on the updateType\n */\nexport function updateSearchString({\n  searchString,\n  adapter,\n  navigate,\n  updateType,\n}: {\n  searchString: string;\n  adapter: QueryParamAdapter;\n  navigate: boolean;\n  updateType?: UrlUpdateType;\n}) {\n  const currentLocation = adapter.location;\n\n  // update the location and URL\n  const newLocation: PartialLocation = {\n    ...currentLocation,\n    search: searchString,\n  };\n\n  if (navigate) {\n    // be defensive about checking updateType since it is somewhat easy to\n    // accidentally pass a second argument to the setter.\n    if (typeof updateType === 'string' && updateType.startsWith('replace')) {\n      adapter.replace(newLocation);\n    } else {\n      adapter.push(newLocation);\n    }\n  }\n}\n\ntype UpdateArgs = Parameters<typeof getUpdatedSearchString>[0] & {\n  adapter: QueryParamAdapter;\n};\n\nconst immediateTask = (task: Function) => task();\nconst timeoutTask = (task: Function) => setTimeout(() => task(), 0);\n// alternative could be native `queueMicrotask`\n\nconst updateQueue: UpdateArgs[] = [];\n\n/**\n * support batching by enqueuing updates (if immediate is not true)\n */\nexport function enqueueUpdate(\n  args: UpdateArgs,\n  { immediate }: { immediate?: boolean } = {}\n) {\n  updateQueue.push(args);\n  let scheduleTask = immediate ? immediateTask : timeoutTask;\n\n  if (updateQueue.length === 1) {\n    scheduleTask(() => {\n      const updates = updateQueue.slice();\n      updateQueue.length = 0;\n      const initialSearchString = updates[0].currentSearchString;\n\n      let searchString: string | undefined;\n      for (let i = 0; i < updates.length; ++i) {\n        const modifiedUpdate: UpdateArgs =\n          i === 0\n            ? updates[i]\n            : { ...updates[i], currentSearchString: searchString! };\n        searchString = getUpdatedSearchString(modifiedUpdate);\n      }\n\n      // do not update unnecessarily #234\n      if (\n        args.options.skipUpdateWhenNoChange &&\n        searchString === initialSearchString\n      ) {\n        return;\n      }\n\n      updateSearchString({\n        searchString: searchString ?? '',\n        adapter: updates[updates.length - 1].adapter,\n        navigate: true,\n        updateType: updates[updates.length - 1].updateType,\n      });\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}