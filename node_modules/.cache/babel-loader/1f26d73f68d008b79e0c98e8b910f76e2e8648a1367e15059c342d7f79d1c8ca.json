{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = generateCode;\nfunction _convertSourceMap() {\n  const data = require(\"convert-source-map\");\n  _convertSourceMap = function () {\n    return data;\n  };\n  return data;\n}\nfunction _generator() {\n  const data = require(\"@babel/generator\");\n  _generator = function () {\n    return data;\n  };\n  return data;\n}\nvar _mergeMap = require(\"./merge-map\");\nfunction generateCode(pluginPasses, file) {\n  const {\n    opts,\n    ast,\n    code,\n    inputMap\n  } = file;\n  const {\n    generatorOpts\n  } = opts;\n  const results = [];\n  for (const plugins of pluginPasses) {\n    for (const plugin of plugins) {\n      const {\n        generatorOverride\n      } = plugin;\n      if (generatorOverride) {\n        const result = generatorOverride(ast, generatorOpts, code, _generator().default);\n        if (result !== undefined) results.push(result);\n      }\n    }\n  }\n  let result;\n  if (results.length === 0) {\n    result = (0, _generator().default)(ast, generatorOpts, code);\n  } else if (results.length === 1) {\n    result = results[0];\n    if (typeof result.then === \"function\") {\n      throw new Error(`You appear to be using an async codegen plugin, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, ` + `you may need to upgrade your @babel/core version.`);\n    }\n  } else {\n    throw new Error(\"More than one plugin attempted to override codegen.\");\n  }\n  let {\n    code: outputCode,\n    decodedMap: outputMap = result.map\n  } = result;\n  if (outputMap) {\n    if (inputMap) {\n      outputMap = (0, _mergeMap.default)(inputMap.toObject(), outputMap, generatorOpts.sourceFileName);\n    } else {\n      outputMap = result.map;\n    }\n  }\n  if (opts.sourceMaps === \"inline\" || opts.sourceMaps === \"both\") {\n    outputCode += \"\\n\" + _convertSourceMap().fromObject(outputMap).toComment();\n  }\n  if (opts.sourceMaps === \"inline\") {\n    outputMap = null;\n  }\n  return {\n    outputCode,\n    outputMap\n  };\n}\n0 && 0;","map":{"version":3,"mappings":";;;;;;AACA;EAAA;EAAAA;IAAA;EAAA;EAAA;AAAA;AAEA;EAAA;EAAAC;IAAA;EAAA;EAAA;AAAA;AAGA;AAEe,SAASC,YAAY,CAClCC,YAA0B,EAC1BC,IAAU,EAIV;EACA,MAAM;IAAEC,IAAI;IAAEC,GAAG;IAAEC,IAAI;IAAEC;EAAS,CAAC,GAAGJ,IAAI;EAC1C,MAAM;IAAEK;EAAc,CAAC,GAAGJ,IAAI;EAE9B,MAAMK,OAAO,GAAG,EAAE;EAClB,KAAK,MAAMC,OAAO,IAAIR,YAAY,EAAE;IAClC,KAAK,MAAMS,MAAM,IAAID,OAAO,EAAE;MAC5B,MAAM;QAAEE;MAAkB,CAAC,GAAGD,MAAM;MACpC,IAAIC,iBAAiB,EAAE;QACrB,MAAMC,MAAM,GAAGD,iBAAiB,CAACP,GAAG,EAAEG,aAAa,EAAEF,IAAI,EAAEQ,oBAAQ,CAAC;QAEpE,IAAID,MAAM,KAAKE,SAAS,EAAEN,OAAO,CAACO,IAAI,CAACH,MAAM,CAAC;MAChD;IACF;EACF;EAEA,IAAIA,MAAM;EACV,IAAIJ,OAAO,CAACQ,MAAM,KAAK,CAAC,EAAE;IACxBJ,MAAM,GAAG,wBAAQ,EAACR,GAAG,EAAEG,aAAa,EAAEF,IAAI,CAAC;EAC7C,CAAC,MAAM,IAAIG,OAAO,CAACQ,MAAM,KAAK,CAAC,EAAE;IAC/BJ,MAAM,GAAGJ,OAAO,CAAC,CAAC,CAAC;IAEnB,IAAI,OAAOI,MAAM,CAACK,IAAI,KAAK,UAAU,EAAE;MACrC,MAAM,IAAIC,KAAK,CACZ,kDAAiD,GAC/C,wDAAuD,GACvD,sCAAqC,GACrC,mDAAkD,CACtD;IACH;EACF,CAAC,MAAM;IACL,MAAM,IAAIA,KAAK,CAAC,qDAAqD,CAAC;EACxE;EAKA,IAAI;IAAEb,IAAI,EAAEc,UAAU;IAAEC,UAAU,EAAEC,SAAS,GAAGT,MAAM,CAACU;EAAI,CAAC,GAAGV,MAAM;EAErE,IAAIS,SAAS,EAAE;IACb,IAAIf,QAAQ,EAAE;MAEZe,SAAS,GAAG,qBAAc,EACxBf,QAAQ,CAACiB,QAAQ,EAAE,EACnBF,SAAS,EACTd,aAAa,CAACiB,cAAc,CAC7B;IACH,CAAC,MAAM;MAGLH,SAAS,GAAGT,MAAM,CAACU,GAAG;IACxB;EACF;EAEA,IAAInB,IAAI,CAACsB,UAAU,KAAK,QAAQ,IAAItB,IAAI,CAACsB,UAAU,KAAK,MAAM,EAAE;IAC9DN,UAAU,IAAI,IAAI,GAAGO,mBAAgB,CAACC,UAAU,CAACN,SAAS,CAAC,CAACO,SAAS,EAAE;EACzE;EAEA,IAAIzB,IAAI,CAACsB,UAAU,KAAK,QAAQ,EAAE;IAChCJ,SAAS,GAAG,IAAI;EAClB;EAEA,OAAO;IAAEF,UAAU;IAAEE;EAAU,CAAC;AAClC;AAAC","names":["_convertSourceMap","_generator","generateCode","pluginPasses","file","opts","ast","code","inputMap","generatorOpts","results","plugins","plugin","generatorOverride","result","generate","undefined","push","length","then","Error","outputCode","decodedMap","outputMap","map","toObject","sourceFileName","sourceMaps","convertSourceMap","fromObject","toComment"],"sources":["/Users/elahehaslani/Work/Sample-Project/ticket-booking/ticket-booking/node_modules/@babel/core/src/transformation/file/generate.ts"],"sourcesContent":["import type { PluginPasses } from \"../../config\";\nimport convertSourceMap from \"convert-source-map\";\ntype SourceMap = any;\nimport generate from \"@babel/generator\";\n\nimport type File from \"./file\";\nimport mergeSourceMap from \"./merge-map\";\n\nexport default function generateCode(\n  pluginPasses: PluginPasses,\n  file: File,\n): {\n  outputCode: string;\n  outputMap: SourceMap | null;\n} {\n  const { opts, ast, code, inputMap } = file;\n  const { generatorOpts } = opts;\n\n  const results = [];\n  for (const plugins of pluginPasses) {\n    for (const plugin of plugins) {\n      const { generatorOverride } = plugin;\n      if (generatorOverride) {\n        const result = generatorOverride(ast, generatorOpts, code, generate);\n\n        if (result !== undefined) results.push(result);\n      }\n    }\n  }\n\n  let result;\n  if (results.length === 0) {\n    result = generate(ast, generatorOpts, code);\n  } else if (results.length === 1) {\n    result = results[0];\n\n    if (typeof result.then === \"function\") {\n      throw new Error(\n        `You appear to be using an async codegen plugin, ` +\n          `which your current version of Babel does not support. ` +\n          `If you're using a published plugin, ` +\n          `you may need to upgrade your @babel/core version.`,\n      );\n    }\n  } else {\n    throw new Error(\"More than one plugin attempted to override codegen.\");\n  }\n\n  // Decoded maps are faster to merge, so we attempt to get use the decodedMap\n  // first. But to preserve backwards compat with older Generator, we'll fall\n  // back to the encoded map.\n  let { code: outputCode, decodedMap: outputMap = result.map } = result;\n\n  if (outputMap) {\n    if (inputMap) {\n      // mergeSourceMap returns an encoded map\n      outputMap = mergeSourceMap(\n        inputMap.toObject(),\n        outputMap,\n        generatorOpts.sourceFileName,\n      );\n    } else {\n      // We cannot output a decoded map, so retrieve the encoded form. Because\n      // the decoded form is free, it's fine to prioritize decoded first.\n      outputMap = result.map;\n    }\n  }\n\n  if (opts.sourceMaps === \"inline\" || opts.sourceMaps === \"both\") {\n    outputCode += \"\\n\" + convertSourceMap.fromObject(outputMap).toComment();\n  }\n\n  if (opts.sourceMaps === \"inline\") {\n    outputMap = null;\n  }\n\n  return { outputCode, outputMap };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}