{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.couldBeBaseType = couldBeBaseType;\nexports.getTypeAnnotation = getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.isGenericType = isGenericType;\nvar inferers = require(\"./inferers\");\nvar _t = require(\"@babel/types\");\nconst {\n  anyTypeAnnotation,\n  isAnyTypeAnnotation,\n  isArrayTypeAnnotation,\n  isBooleanTypeAnnotation,\n  isEmptyTypeAnnotation,\n  isFlowBaseAnnotation,\n  isGenericTypeAnnotation,\n  isIdentifier,\n  isMixedTypeAnnotation,\n  isNumberTypeAnnotation,\n  isStringTypeAnnotation,\n  isTSArrayType,\n  isTSTypeAnnotation,\n  isTSTypeReference,\n  isTupleTypeAnnotation,\n  isTypeAnnotation,\n  isUnionTypeAnnotation,\n  isVoidTypeAnnotation,\n  stringTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\nfunction getTypeAnnotation() {\n  let type = this.getData(\"typeAnnotation\");\n  if (type != null) {\n    return type;\n  }\n  type = this._getTypeAnnotation() || anyTypeAnnotation();\n  if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {\n    type = type.typeAnnotation;\n  }\n  this.setData(\"typeAnnotation\", type);\n  return type;\n}\nconst typeAnnotationInferringNodes = new WeakSet();\nfunction _getTypeAnnotation() {\n  const node = this.node;\n  if (!node) {\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return stringTypeAnnotation();\n      }\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return anyTypeAnnotation();\n      }\n      return voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n  if (typeAnnotationInferringNodes.has(node)) {\n    return;\n  }\n  typeAnnotationInferringNodes.add(node);\n  try {\n    var _inferer;\n    let inferer = inferers[node.type];\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n    inferer = inferers[this.parentPath.type];\n    if ((_inferer = inferer) != null && _inferer.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\nfunction couldBeBaseType(name) {\n  const type = this.getTypeAnnotation();\n  if (isAnyTypeAnnotation(type)) return true;\n  if (isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\nfunction baseTypeStrictlyMatches(rightArg) {\n  const left = this.getTypeAnnotation();\n  const right = rightArg.getTypeAnnotation();\n  if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n  return false;\n}\nfunction isGenericType(genericName) {\n  const type = this.getTypeAnnotation();\n  if (genericName === \"Array\") {\n    if (isTSArrayType(type) || isArrayTypeAnnotation(type) || isTupleTypeAnnotation(type)) {\n      return true;\n    }\n  }\n  return isGenericTypeAnnotation(type) && isIdentifier(type.id, {\n    name: genericName\n  }) || isTSTypeReference(type) && isIdentifier(type.typeName, {\n    name: genericName\n  });\n}","map":{"version":3,"mappings":";;;;;;;;;;;AACA;AACA;AAqBsB;EApBpBA,iBAAiB;EACjBC,mBAAmB;EACnBC,qBAAqB;EACrBC,uBAAuB;EACvBC,qBAAqB;EACrBC,oBAAoB;EACpBC,uBAAuB;EACvBC,YAAY;EACZC,qBAAqB;EACrBC,sBAAsB;EACtBC,sBAAsB;EACtBC,aAAa;EACbC,kBAAkB;EAClBC,iBAAiB;EACjBC,qBAAqB;EACrBC,gBAAgB;EAChBC,qBAAqB;EACrBC,oBAAoB;EACpBC,oBAAoB;EACpBC;AAAkB;AAQb,SAASC,iBAAiB,GAAwC;EACvE,IAAIC,IAAI,GAAG,IAAI,CAACC,OAAO,CAAC,gBAAgB,CAAC;EACzC,IAAID,IAAI,IAAI,IAAI,EAAE;IAChB,OAAOA,IAAI;EACb;EACAA,IAAI,GAAG,IAAI,CAACE,kBAAkB,EAAE,IAAIvB,iBAAiB,EAAE;EACvD,IAAIe,gBAAgB,CAACM,IAAI,CAAC,IAAIT,kBAAkB,CAACS,IAAI,CAAC,EAAE;IACtDA,IAAI,GAAGA,IAAI,CAACG,cAAc;EAC5B;EACA,IAAI,CAACC,OAAO,CAAC,gBAAgB,EAAEJ,IAAI,CAAC;EACpC,OAAOA,IAAI;AACb;AAKA,MAAMK,4BAA4B,GAAG,IAAIC,OAAO,EAAE;AAM3C,SAASJ,kBAAkB,GAAsB;EACtD,MAAMK,IAAI,GAAG,IAAI,CAACA,IAAI;EAEtB,IAAI,CAACA,IAAI,EAAE;IAET,IAAI,IAAI,CAACC,GAAG,KAAK,MAAM,IAAI,IAAI,CAACC,UAAU,CAACC,oBAAoB,EAAE,EAAE;MACjE,MAAMC,MAAM,GAAG,IAAI,CAACF,UAAU,CAACA,UAAU;MACzC,MAAMG,YAAY,GAAGD,MAAM,CAACF,UAAU;MAGtC,IAAIE,MAAM,CAACH,GAAG,KAAK,MAAM,IAAII,YAAY,CAACC,gBAAgB,EAAE,EAAE;QAC5D,OAAOhB,oBAAoB,EAAE;MAC/B;MAGA,IAAIc,MAAM,CAACH,GAAG,KAAK,MAAM,IAAII,YAAY,CAACE,gBAAgB,EAAE,EAAE;QAC5D,OAAOnC,iBAAiB,EAAE;MAC5B;MAEA,OAAOmB,kBAAkB,EAAE;IAC7B,CAAC,MAAM;MACL;IACF;EACF;EAGA,IAAIS,IAAI,CAACJ,cAAc,EAAE;IAEvB,OAAOI,IAAI,CAACJ,cAAc;EAC5B;EAEA,IAAIE,4BAA4B,CAACU,GAAG,CAACR,IAAI,CAAC,EAAE;IAE1C;EACF;EACAF,4BAA4B,CAACW,GAAG,CAACT,IAAI,CAAC;EAEtC,IAAI;IAAA;IACF,IAAIU,OAAO,GAETC,QAAQ,CAACX,IAAI,CAACP,IAAI,CAAC;IACrB,IAAIiB,OAAO,EAAE;MACX,OAAOA,OAAO,CAACE,IAAI,CAAC,IAAI,EAAEZ,IAAI,CAAC;IACjC;IAGAU,OAAO,GAAGC,QAAQ,CAAC,IAAI,CAACT,UAAU,CAACT,IAAI,CAAC;IACxC,gBAAIiB,OAAO,aAAPG,SAASC,WAAW,EAAE;MACxB,OAAO,IAAI,CAACZ,UAAU,CAACV,iBAAiB,EAAE;IAC5C;EACF,CAAC,SAAS;IACRM,4BAA4B,CAACiB,MAAM,CAACf,IAAI,CAAC;EAC3C;AACF;AAEO,SAASgB,UAAU,CAExBC,QAAgB,EAChBC,IAAc,EACL;EACT,OAAOC,WAAW,CAACF,QAAQ,EAAE,IAAI,CAACzB,iBAAiB,EAAE,EAAE0B,IAAI,CAAC;AAC9D;AAEA,SAASC,WAAW,CAClBF,QAAgB,EAChBxB,IAA4B,EAC5ByB,IAAc,EACL;EACT,IAAID,QAAQ,KAAK,QAAQ,EAAE;IACzB,OAAOnC,sBAAsB,CAACW,IAAI,CAAC;EACrC,CAAC,MAAM,IAAIwB,QAAQ,KAAK,QAAQ,EAAE;IAChC,OAAOpC,sBAAsB,CAACY,IAAI,CAAC;EACrC,CAAC,MAAM,IAAIwB,QAAQ,KAAK,SAAS,EAAE;IACjC,OAAO1C,uBAAuB,CAACkB,IAAI,CAAC;EACtC,CAAC,MAAM,IAAIwB,QAAQ,KAAK,KAAK,EAAE;IAC7B,OAAO5C,mBAAmB,CAACoB,IAAI,CAAC;EAClC,CAAC,MAAM,IAAIwB,QAAQ,KAAK,OAAO,EAAE;IAC/B,OAAOrC,qBAAqB,CAACa,IAAI,CAAC;EACpC,CAAC,MAAM,IAAIwB,QAAQ,KAAK,OAAO,EAAE;IAC/B,OAAOzC,qBAAqB,CAACiB,IAAI,CAAC;EACpC,CAAC,MAAM,IAAIwB,QAAQ,KAAK,MAAM,EAAE;IAC9B,OAAO5B,oBAAoB,CAACI,IAAI,CAAC;EACnC,CAAC,MAAM;IACL,IAAIyB,IAAI,EAAE;MACR,OAAO,KAAK;IACd,CAAC,MAAM;MACL,MAAM,IAAIE,KAAK,CAAE,qBAAoBH,QAAS,EAAC,CAAC;IAClD;EACF;AACF;AAEO,SAASI,eAAe,CAAiBC,IAAY,EAAW;EACrE,MAAM7B,IAAI,GAAG,IAAI,CAACD,iBAAiB,EAAE;EACrC,IAAInB,mBAAmB,CAACoB,IAAI,CAAC,EAAE,OAAO,IAAI;EAE1C,IAAIL,qBAAqB,CAACK,IAAI,CAAC,EAAE;IAC/B,KAAK,MAAM8B,KAAK,IAAI9B,IAAI,CAAC+B,KAAK,EAAE;MAC9B,IAAInD,mBAAmB,CAACkD,KAAK,CAAC,IAAIJ,WAAW,CAACG,IAAI,EAAEC,KAAK,EAAE,IAAI,CAAC,EAAE;QAChE,OAAO,IAAI;MACb;IACF;IACA,OAAO,KAAK;EACd,CAAC,MAAM;IACL,OAAOJ,WAAW,CAACG,IAAI,EAAE7B,IAAI,EAAE,IAAI,CAAC;EACtC;AACF;AAEO,SAASgC,uBAAuB,CAErCC,QAAkB,EACT;EACT,MAAMC,IAAI,GAAG,IAAI,CAACnC,iBAAiB,EAAE;EACrC,MAAMoC,KAAK,GAAGF,QAAQ,CAAClC,iBAAiB,EAAE;EAE1C,IAAI,CAACnB,mBAAmB,CAACsD,IAAI,CAAC,IAAIlD,oBAAoB,CAACkD,IAAI,CAAC,EAAE;IAC5D,OAAOC,KAAK,CAACnC,IAAI,KAAKkC,IAAI,CAAClC,IAAI;EACjC;EACA,OAAO,KAAK;AACd;AAEO,SAASoC,aAAa,CAAiBC,WAAmB,EAAW;EAC1E,MAAMrC,IAAI,GAAG,IAAI,CAACD,iBAAiB,EAAE;EACrC,IAAIsC,WAAW,KAAK,OAAO,EAAE;IAE3B,IACE/C,aAAa,CAACU,IAAI,CAAC,IACnBnB,qBAAqB,CAACmB,IAAI,CAAC,IAC3BP,qBAAqB,CAACO,IAAI,CAAC,EAC3B;MACA,OAAO,IAAI;IACb;EACF;EACA,OACGf,uBAAuB,CAACe,IAAI,CAAC,IAC5Bd,YAAY,CAACc,IAAI,CAACsC,EAAE,EAAE;IACpBT,IAAI,EAAEQ;EACR,CAAC,CAAC,IACH7C,iBAAiB,CAACQ,IAAI,CAAC,IACtBd,YAAY,CAACc,IAAI,CAACuC,QAAQ,EAAE;IAC1BV,IAAI,EAAEQ;EACR,CAAC,CAAE;AAET","names":["anyTypeAnnotation","isAnyTypeAnnotation","isArrayTypeAnnotation","isBooleanTypeAnnotation","isEmptyTypeAnnotation","isFlowBaseAnnotation","isGenericTypeAnnotation","isIdentifier","isMixedTypeAnnotation","isNumberTypeAnnotation","isStringTypeAnnotation","isTSArrayType","isTSTypeAnnotation","isTSTypeReference","isTupleTypeAnnotation","isTypeAnnotation","isUnionTypeAnnotation","isVoidTypeAnnotation","stringTypeAnnotation","voidTypeAnnotation","getTypeAnnotation","type","getData","_getTypeAnnotation","typeAnnotation","setData","typeAnnotationInferringNodes","WeakSet","node","key","parentPath","isVariableDeclarator","declar","declarParent","isForInStatement","isForOfStatement","has","add","inferer","inferers","call","_inferer","validParent","delete","isBaseType","baseName","soft","_isBaseType","Error","couldBeBaseType","name","type2","types","baseTypeStrictlyMatches","rightArg","left","right","isGenericType","genericName","id","typeName"],"sources":["/Users/elahehaslani/Work/Sample-Project/ticket-booking/ticket-booking/node_modules/@babel/traverse/src/path/inference/index.ts"],"sourcesContent":["import type NodePath from \"../index\";\nimport * as inferers from \"./inferers\";\nimport {\n  anyTypeAnnotation,\n  isAnyTypeAnnotation,\n  isArrayTypeAnnotation,\n  isBooleanTypeAnnotation,\n  isEmptyTypeAnnotation,\n  isFlowBaseAnnotation,\n  isGenericTypeAnnotation,\n  isIdentifier,\n  isMixedTypeAnnotation,\n  isNumberTypeAnnotation,\n  isStringTypeAnnotation,\n  isTSArrayType,\n  isTSTypeAnnotation,\n  isTSTypeReference,\n  isTupleTypeAnnotation,\n  isTypeAnnotation,\n  isUnionTypeAnnotation,\n  isVoidTypeAnnotation,\n  stringTypeAnnotation,\n  voidTypeAnnotation,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\n/**\n * Infer the type of the current `NodePath`.\n */\n\nexport function getTypeAnnotation(this: NodePath): t.FlowType | t.TSType {\n  let type = this.getData(\"typeAnnotation\");\n  if (type != null) {\n    return type;\n  }\n  type = this._getTypeAnnotation() || anyTypeAnnotation();\n  if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {\n    type = type.typeAnnotation;\n  }\n  this.setData(\"typeAnnotation\", type);\n  return type;\n}\n\n// Used to avoid infinite recursion in cases like\n//   var b, c; if (0) { c = 1; b = c; } c = b;\n// It also works with indirect recursion.\nconst typeAnnotationInferringNodes = new WeakSet();\n\n/**\n * todo: split up this method\n */\n\nexport function _getTypeAnnotation(this: NodePath): any {\n  const node = this.node;\n\n  if (!node) {\n    // handle initializerless variables, add in checks for loop initializers too\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      // for (let NODE in bar) {}\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return stringTypeAnnotation();\n      }\n\n      // for (let NODE of bar) {}\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return anyTypeAnnotation();\n      }\n\n      return voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  // @ts-expect-error typeAnnotation may not index node\n  if (node.typeAnnotation) {\n    // @ts-expect-error typeAnnotation may not index node\n    return node.typeAnnotation;\n  }\n\n  if (typeAnnotationInferringNodes.has(node)) {\n    // Bail out from type inference to avoid infinite loops\n    return;\n  }\n  typeAnnotationInferringNodes.add(node);\n\n  try {\n    let inferer =\n      // @ts-expect-error inferers do not cover all AST types\n      inferers[node.type];\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n\n    // @ts-expect-error inferers do not cover all AST types\n    inferer = inferers[this.parentPath.type];\n    if (inferer?.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\n\nexport function isBaseType(\n  this: NodePath,\n  baseName: string,\n  soft?: boolean,\n): boolean {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(\n  baseName: string,\n  type?: t.FlowType | t.TSType,\n  soft?: boolean,\n): boolean {\n  if (baseName === \"string\") {\n    return isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\n\nexport function couldBeBaseType(this: NodePath, name: string): boolean {\n  const type = this.getTypeAnnotation();\n  if (isAnyTypeAnnotation(type)) return true;\n\n  if (isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nexport function baseTypeStrictlyMatches(\n  this: NodePath,\n  rightArg: NodePath,\n): boolean {\n  const left = this.getTypeAnnotation();\n  const right = rightArg.getTypeAnnotation();\n\n  if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n  return false;\n}\n\nexport function isGenericType(this: NodePath, genericName: string): boolean {\n  const type = this.getTypeAnnotation();\n  if (genericName === \"Array\") {\n    // T[]\n    if (\n      isTSArrayType(type) ||\n      isArrayTypeAnnotation(type) ||\n      isTupleTypeAnnotation(type)\n    ) {\n      return true;\n    }\n  }\n  return (\n    (isGenericTypeAnnotation(type) &&\n      isIdentifier(type.id, {\n        name: genericName,\n      })) ||\n    (isTSTypeReference(type) &&\n      isIdentifier(type.typeName, {\n        name: genericName,\n      }))\n  );\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}