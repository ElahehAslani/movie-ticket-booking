{"ast":null,"code":"function getEncodedValue(input, allowEmptyString) {\n  if (input == null) {\n    return input;\n  }\n  if (input.length === 0 && (!allowEmptyString || allowEmptyString && input !== \"\")) {\n    return null;\n  }\n  const str = input instanceof Array ? input[0] : input;\n  if (str == null) {\n    return str;\n  }\n  if (!allowEmptyString && str === \"\") {\n    return null;\n  }\n  return str;\n}\nfunction getEncodedValueArray(input) {\n  if (input == null) {\n    return input;\n  }\n  return input instanceof Array ? input : input === \"\" ? [] : [input];\n}\nfunction encodeDate(date) {\n  if (date == null) {\n    return date;\n  }\n  const year = date.getFullYear();\n  const month = date.getMonth() + 1;\n  const day = date.getDate();\n  return `${year}-${month < 10 ? `0${month}` : month}-${day < 10 ? `0${day}` : day}`;\n}\nfunction decodeDate(input) {\n  const dateString = getEncodedValue(input);\n  if (dateString == null) return dateString;\n  const parts = dateString.split(\"-\");\n  if (parts[1] != null) {\n    parts[1] -= 1;\n  } else {\n    parts[1] = 0;\n    parts[2] = 1;\n  }\n  const decoded = new Date(...parts);\n  if (isNaN(decoded.getTime())) {\n    return null;\n  }\n  return decoded;\n}\nfunction encodeDateTime(date) {\n  if (date == null) {\n    return date;\n  }\n  return date.toISOString();\n}\nfunction decodeDateTime(input) {\n  const dateString = getEncodedValue(input);\n  if (dateString == null) return dateString;\n  const decoded = new Date(dateString);\n  if (isNaN(decoded.getTime())) {\n    return null;\n  }\n  return decoded;\n}\nfunction encodeBoolean(bool) {\n  if (bool == null) {\n    return bool;\n  }\n  return bool ? \"1\" : \"0\";\n}\nfunction decodeBoolean(input) {\n  const boolStr = getEncodedValue(input);\n  if (boolStr == null) return boolStr;\n  if (boolStr === \"1\") {\n    return true;\n  } else if (boolStr === \"0\") {\n    return false;\n  }\n  return null;\n}\nfunction encodeNumber(num) {\n  if (num == null) {\n    return num;\n  }\n  return String(num);\n}\nfunction decodeNumber(input) {\n  const numStr = getEncodedValue(input);\n  if (numStr == null) return numStr;\n  if (numStr === \"\") return null;\n  const result = +numStr;\n  return result;\n}\nfunction encodeString(str) {\n  if (str == null) {\n    return str;\n  }\n  return String(str);\n}\nfunction decodeString(input) {\n  const str = getEncodedValue(input, true);\n  if (str == null) return str;\n  return String(str);\n}\nfunction decodeEnum(input, enumValues) {\n  const str = decodeString(input);\n  if (str == null) return str;\n  return enumValues.includes(str) ? str : void 0;\n}\nfunction decodeArrayEnum(input, enumValues) {\n  const arr = decodeArray(input);\n  if (arr == null) return arr;\n  if (!arr.length) return void 0;\n  return arr.every(str => str != null && enumValues.includes(str)) ? arr : void 0;\n}\nfunction decodeDelimitedArrayEnum(input, enumValues) {\n  let entrySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"_\";\n  if (input != null && Array.isArray(input) && !input.length) return void 0;\n  const arr = decodeDelimitedArray(input, entrySeparator);\n  return decodeArrayEnum(arr, enumValues);\n}\nfunction encodeJson(any) {\n  if (any == null) {\n    return any;\n  }\n  return JSON.stringify(any);\n}\nfunction decodeJson(input) {\n  const jsonStr = getEncodedValue(input);\n  if (jsonStr == null) return jsonStr;\n  let result = null;\n  try {\n    result = JSON.parse(jsonStr);\n  } catch (e) {}\n  return result;\n}\nfunction encodeArray(array) {\n  if (array == null) {\n    return array;\n  }\n  return array;\n}\nfunction decodeArray(input) {\n  const arr = getEncodedValueArray(input);\n  if (arr == null) return arr;\n  return arr;\n}\nfunction encodeNumericArray(array) {\n  if (array == null) {\n    return array;\n  }\n  return array.map(String);\n}\nfunction decodeNumericArray(input) {\n  const arr = decodeArray(input);\n  if (arr == null) return arr;\n  return arr.map(d => d === \"\" || d == null ? null : +d);\n}\nfunction encodeDelimitedArray(array) {\n  let entrySeparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"_\";\n  if (array == null) {\n    return array;\n  }\n  return array.join(entrySeparator);\n}\nfunction decodeDelimitedArray(input) {\n  let entrySeparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"_\";\n  const arrayStr = getEncodedValue(input, true);\n  if (arrayStr == null) return arrayStr;\n  if (arrayStr === \"\") return [];\n  return arrayStr.split(entrySeparator);\n}\nconst encodeDelimitedNumericArray = encodeDelimitedArray;\nfunction decodeDelimitedNumericArray(arrayStr) {\n  let entrySeparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"_\";\n  const decoded = decodeDelimitedArray(arrayStr, entrySeparator);\n  if (decoded == null) return decoded;\n  return decoded.map(d => d === \"\" || d == null ? null : +d);\n}\nfunction encodeObject(obj) {\n  let keyValSeparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"-\";\n  let entrySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"_\";\n  if (obj == null) return obj;\n  if (!Object.keys(obj).length) return \"\";\n  return Object.keys(obj).map(key => `${key}${keyValSeparator}${obj[key]}`).join(entrySeparator);\n}\nfunction decodeObject(input) {\n  let keyValSeparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"-\";\n  let entrySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"_\";\n  const objStr = getEncodedValue(input, true);\n  if (objStr == null) return objStr;\n  if (objStr === \"\") return {};\n  const obj = {};\n  const keyValSeparatorRegExp = new RegExp(`${keyValSeparator}(.*)`);\n  objStr.split(entrySeparator).forEach(entryStr => {\n    const [key, value] = entryStr.split(keyValSeparatorRegExp);\n    obj[key] = value;\n  });\n  return obj;\n}\nconst encodeNumericObject = encodeObject;\nfunction decodeNumericObject(input) {\n  let keyValSeparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"-\";\n  let entrySeparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"_\";\n  const decoded = decodeObject(input, keyValSeparator, entrySeparator);\n  if (decoded == null) return decoded;\n  const decodedNumberObj = {};\n  for (const key of Object.keys(decoded)) {\n    decodedNumberObj[key] = decodeNumber(decoded[key]);\n  }\n  return decodedNumberObj;\n}\nexport { decodeArray, decodeArrayEnum, decodeBoolean, decodeDate, decodeDateTime, decodeDelimitedArray, decodeDelimitedArrayEnum, decodeDelimitedNumericArray, decodeEnum, decodeJson, decodeNumber, decodeNumericArray, decodeNumericObject, decodeObject, decodeString, encodeArray, encodeBoolean, encodeDate, encodeDateTime, encodeDelimitedArray, encodeDelimitedNumericArray, encodeJson, encodeNumber, encodeNumericArray, encodeNumericObject, encodeObject, encodeString };","map":{"version":3,"mappings":"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","names":["getEncodedValue","input","allowEmptyString","length","str","Array","getEncodedValueArray","encodeDate","date","year","getFullYear","month","getMonth","day","getDate","decodeDate","dateString","parts","split","decoded","Date","isNaN","getTime","encodeDateTime","toISOString","decodeDateTime","encodeBoolean","bool","decodeBoolean","boolStr","encodeNumber","num","String","decodeNumber","numStr","result","encodeString","decodeString","decodeEnum","enumValues","includes","decodeArrayEnum","arr","decodeArray","every","decodeDelimitedArrayEnum","entrySeparator","isArray","decodeDelimitedArray","encodeJson","any","JSON","stringify","decodeJson","jsonStr","parse","e","encodeArray","array","encodeNumericArray","map","decodeNumericArray","d","encodeDelimitedArray","join","arrayStr","encodeDelimitedNumericArray","decodeDelimitedNumericArray","encodeObject","obj","keyValSeparator","Object","keys","key","decodeObject","objStr","keyValSeparatorRegExp","RegExp","forEach","entryStr","value","encodeNumericObject","decodeNumericObject","decodedNumberObj"],"sources":["/Users/elahehaslani/Work/Sample-Project/ticket-booking/ticket-booking/node_modules/serialize-query-params/src/serialize.ts"],"sourcesContent":["/**\n * Interprets an encoded string and returns either the string or null/undefined if not available.\n * Ignores array inputs (takes just first element in array)\n * @param input encoded string\n */\nfunction getEncodedValue(\n  input: string | (string | null)[] | null | undefined,\n  allowEmptyString?: boolean\n): string | null | undefined {\n  if (input == null) {\n    return input;\n  }\n  // '' or []\n  if (\n    input.length === 0 &&\n    (!allowEmptyString || (allowEmptyString && input !== ''))\n  ) {\n    return null;\n  }\n\n  const str = input instanceof Array ? input[0] : input;\n  if (str == null) {\n    return str;\n  }\n  if (!allowEmptyString && str === '') {\n    return null;\n  }\n\n  return str;\n}\n\n/**\n * Interprets an encoded string and return null/undefined or an array with\n * the encoded string contents\n * @param input encoded string\n */\nfunction getEncodedValueArray(\n  input: string | (string | null)[] | null | undefined\n): (string | null)[] | null | undefined {\n  if (input == null) {\n    return input;\n  }\n\n  return input instanceof Array ? input : input === '' ? [] : [input];\n}\n\n/**\n * Encodes a date as a string in YYYY-MM-DD format.\n *\n * @param {Date} date\n * @return {String} the encoded date\n */\nexport function encodeDate(\n  date: Date | null | undefined\n): string | null | undefined {\n  if (date == null) {\n    return date;\n  }\n\n  const year = date.getFullYear();\n  const month = date.getMonth() + 1;\n  const day = date.getDate();\n\n  return `${year}-${month < 10 ? `0${month}` : month}-${\n    day < 10 ? `0${day}` : day\n  }`;\n}\n\n/**\n * Converts a date in the format 'YYYY-mm-dd...' into a proper date, because\n * new Date() does not do that correctly. The date can be as complete or incomplete\n * as necessary (aka, '2015', '2015-10', '2015-10-01').\n * It will not work for dates that have times included in them.\n *\n * If an array is provided, only the first entry is used.\n *\n * @param  {String} input String date form like '2015-10-01'\n * @return {Date} parsed date\n */\nexport function decodeDate(\n  input: string | (string | null)[] | null | undefined\n): Date | null | undefined {\n  const dateString = getEncodedValue(input);\n  if (dateString == null) return dateString;\n\n  const parts = dateString.split('-') as any;\n  // may only be a year so won't even have a month\n  if (parts[1] != null) {\n    parts[1] -= 1; // Note: months are 0-based\n  } else {\n    // just a year, set the month and day to the first\n    parts[1] = 0;\n    parts[2] = 1;\n  }\n\n  const decoded = new Date(...(parts as [number, number, number]));\n\n  if (isNaN(decoded.getTime())) {\n    return null;\n  }\n\n  return decoded;\n}\n\n/**\n * Encodes a date as a string in ISO 8601 (\"2019-05-28T10:58:40Z\") format.\n *\n * @param {Date} date\n * @return {String} the encoded date\n */\nexport function encodeDateTime(\n  date: Date | null | undefined\n): string | null | undefined {\n  if (date == null) {\n    return date;\n  }\n\n  return date.toISOString();\n}\n\n/**\n * Converts a date in the https://en.wikipedia.org/wiki/ISO_8601 format.\n * For allowed inputs see specs:\n *  - https://tools.ietf.org/html/rfc2822#page-14\n *  - http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15\n *\n * If an array is provided, only the first entry is used.\n *\n * @param  {String} input String date form like '1995-12-17T03:24:00'\n * @return {Date} parsed date\n */\nexport function decodeDateTime(\n  input: string | (string | null)[] | null | undefined\n): Date | null | undefined {\n  const dateString = getEncodedValue(input);\n  if (dateString == null) return dateString;\n\n  const decoded = new Date(dateString);\n\n  if (isNaN(decoded.getTime())) {\n    return null;\n  }\n\n  return decoded;\n}\n\n/**\n * Encodes a boolean as a string. true -> \"1\", false -> \"0\".\n *\n * @param {Boolean} bool\n * @return {String} the encoded boolean\n */\nexport function encodeBoolean(\n  bool: boolean | null | undefined\n): string | null | undefined {\n  if (bool == null) {\n    return bool;\n  }\n\n  return bool ? '1' : '0';\n}\n\n/**\n * Decodes a boolean from a string. \"1\" -> true, \"0\" -> false.\n * Everything else maps to undefined.\n *\n * If an array is provided, only the first entry is used.\n *\n * @param {String} input the encoded boolean string\n * @return {Boolean} the boolean value\n */\nexport function decodeBoolean(\n  input: string | (string | null)[] | null | undefined\n): boolean | null | undefined {\n  const boolStr = getEncodedValue(input);\n  if (boolStr == null) return boolStr;\n\n  if (boolStr === '1') {\n    return true;\n  } else if (boolStr === '0') {\n    return false;\n  }\n\n  return null;\n}\n\n/**\n * Encodes a number as a string.\n *\n * @param {Number} num\n * @return {String} the encoded number\n */\nexport function encodeNumber(\n  num: number | null | undefined\n): string | null | undefined {\n  if (num == null) {\n    return num;\n  }\n\n  return String(num);\n}\n\n/**\n * Decodes a number from a string. If the number is invalid,\n * it returns undefined.\n *\n * If an array is provided, only the first entry is used.\n *\n * @param {String} input the encoded number string\n * @return {Number} the number value\n */\nexport function decodeNumber(\n  input: string | (string | null)[] | null | undefined\n): number | null | undefined {\n  const numStr = getEncodedValue(input);\n  if (numStr == null) return numStr;\n  if (numStr === '') return null;\n\n  const result = +numStr;\n  return result;\n}\n\n/**\n * Encodes a string while safely handling null and undefined values.\n *\n * @param {String} str a string to encode\n * @return {String} the encoded string\n */\nexport function encodeString(\n  str: string | (string | null)[] | null | undefined\n): string | null | undefined {\n  if (str == null) {\n    return str;\n  }\n\n  return String(str);\n}\n\n/**\n * Decodes a string while safely handling null and undefined values.\n *\n * If an array is provided, only the first entry is used.\n *\n * @param {String} input the encoded string\n * @return {String} the string value\n */\nexport function decodeString(\n  input: string | (string | null)[] | null | undefined\n): string | null | undefined {\n  const str = getEncodedValue(input, true);\n  if (str == null) return str;\n\n  return String(str);\n}\n\n/**\n * Decodes an enum value while safely handling null and undefined values.\n *\n * If an array is provided, only the first entry is used.\n *\n * @param {String} input the encoded string\n * @param {String[]} enumValues allowed enum values\n * @return {String} the string value from enumValues\n */\nexport function decodeEnum<T extends string>(\n  input: string | (string | null)[] | null | undefined,\n  enumValues: T[]\n): T | null | undefined {\n  const str = decodeString(input);\n  if (str == null) return str;\n  return enumValues.includes(str as any) ? (str as T) : undefined;\n}\n\n/**\n * Decodes an enum value from arrays while safely handling null and undefined values.\n *\n * @template T\n * @param {String} input the encoded string\n * @param {T[]} enumValues allowed enum values\n * @return {T[]} the string value from enumValues\n */\nexport function decodeArrayEnum<T extends string>(\n  input: string | (string | null)[] | null | undefined,\n  enumValues: T[]\n): T[] | null | undefined {\n  const arr = decodeArray(input);\n  if (arr == null) return arr;\n  if (!arr.length) return undefined;\n  return arr.every((str) => str != null && enumValues.includes(str as T))\n    ? (arr as T[])\n    : undefined;\n}\n\n/**\n * Decodes an enum value from arrays while safely handling null and undefined values.\n *\n * @template T\n * @param {String} input the encoded string\n * @param {T[]} enumValues allowed enum values\n * @param entrySeparator The array as a string with elements joined by the\n * entry separator\n * @return {T[]} the string value from enumValues\n */\nexport function decodeDelimitedArrayEnum<T extends string>(\n  input: string | (string | null)[] | null | undefined,\n  enumValues: T[],\n  entrySeparator = '_'\n): T[] | null | undefined {\n  if (input != null && Array.isArray(input) && !input.length) return undefined;\n  const arr = decodeDelimitedArray(input, entrySeparator);\n  return decodeArrayEnum(arr, enumValues);\n}\n\n/**\n * Encodes anything as a JSON string.\n *\n * @param {Any} any The thing to be encoded\n * @return {String} The JSON string representation of any\n */\nexport function encodeJson(\n  any: any | null | undefined\n): string | null | undefined {\n  if (any == null) {\n    return any;\n  }\n\n  return JSON.stringify(any);\n}\n\n/**\n * Decodes a JSON string into javascript\n *\n * If an array is provided, only the first entry is used.\n *\n * @param {String} input The JSON string representation\n * @return {Any} The javascript representation\n */\nexport function decodeJson(\n  input: string | (string | null)[] | null | undefined\n): any | null | undefined {\n  const jsonStr = getEncodedValue(input);\n  if (jsonStr == null) return jsonStr;\n\n  let result = null;\n  try {\n    result = JSON.parse(jsonStr);\n  } catch (e) {\n    /* ignore errors, returning undefined */\n  }\n\n  return result;\n}\n\n/**\n * Encodes an array as a JSON string.\n *\n * @param {Array} array The array to be encoded\n * @return {String[]} The array of strings to be put in the URL\n * as repeated query parameters\n */\nexport function encodeArray(\n  array: (string | null)[] | null | undefined\n): (string | null)[] | null | undefined {\n  if (array == null) {\n    return array;\n  }\n\n  return array;\n}\n\n/**\n * Decodes an array or singular value and returns it as an array\n * or undefined if falsy. Filters out undefined values.\n *\n * @param {String | Array} input The input value\n * @return {Array} The javascript representation\n */\nexport function decodeArray(\n  input: string | (string | null)[] | null | undefined\n): (string | null)[] | null | undefined {\n  const arr = getEncodedValueArray(input);\n  if (arr == null) return arr;\n\n  return arr;\n}\n\n/**\n * Encodes a numeric array as a JSON string.\n *\n * @param {Array} array The array to be encoded\n * @return {String[]} The array of strings to be put in the URL\n * as repeated query parameters\n */\nexport function encodeNumericArray(\n  array: (number | null)[] | null | undefined\n): (string | null)[] | null | undefined {\n  if (array == null) {\n    return array;\n  }\n\n  return array.map(String);\n}\n\n/**\n * Decodes an array or singular value and returns it as an array\n * or undefined if falsy. Filters out undefined and NaN values.\n *\n * @param {String | Array} input The input value\n * @return {Array} The javascript representation\n */\nexport function decodeNumericArray(\n  input: string | (string | null)[] | null | undefined\n): (number | null)[] | null | undefined {\n  const arr = decodeArray(input);\n  if (arr == null) return arr;\n\n  return arr.map((d) => (d === '' || d == null ? null : +d));\n}\n\n/**\n * Encodes an array as a delimited string. For example,\n * ['a', 'b'] -> 'a_b' with entrySeparator='_'\n *\n * @param array The array to be encoded\n * @param entrySeparator The string used to delimit entries\n * @return The array as a string with elements joined by the\n * entry separator\n */\nexport function encodeDelimitedArray(\n  array: (string | null)[] | null | undefined,\n  entrySeparator = '_'\n): string | null | undefined {\n  if (array == null) {\n    return array;\n  }\n\n  return array.join(entrySeparator);\n}\n\n/**\n * Decodes a delimited string into javascript array. For example,\n * 'a_b' -> ['a', 'b'] with entrySeparator='_'\n *\n * If an array is provided as input, only the first entry is used.\n *\n * @param {String} input The JSON string representation\n * @param entrySeparator The array as a string with elements joined by the\n * entry separator\n * @return {Array} The javascript representation\n */\nexport function decodeDelimitedArray(\n  input: string | (string | null)[] | null | undefined,\n  entrySeparator = '_'\n): (string | null)[] | null | undefined {\n  const arrayStr = getEncodedValue(input, true);\n  if (arrayStr == null) return arrayStr;\n  if (arrayStr === '') return [];\n\n  return arrayStr.split(entrySeparator);\n}\n\n/**\n * Encodes a numeric array as a delimited string. (alias of encodeDelimitedArray)\n * For example, [1, 2] -> '1_2' with entrySeparator='_'\n *\n * @param {Array} array The array to be encoded\n * @return {String} The JSON string representation of array\n */\nexport const encodeDelimitedNumericArray = encodeDelimitedArray as (\n  array: (number | null)[] | null | undefined,\n  entrySeparator?: string\n) => string | null | undefined;\n\n/**\n * Decodes a delimited string into javascript array where all entries are numbers\n * For example, '1_2' -> [1, 2] with entrySeparator='_'\n *\n * If an array is provided as input, only the first entry is used.\n *\n * @param {String} jsonStr The JSON string representation\n * @return {Array} The javascript representation\n */\nexport function decodeDelimitedNumericArray(\n  arrayStr: string | (string | null)[] | null | undefined,\n  entrySeparator = '_'\n): (number | null)[] | null | undefined {\n  const decoded = decodeDelimitedArray(arrayStr, entrySeparator);\n  if (decoded == null) return decoded;\n\n  return decoded.map((d) => (d === '' || d == null ? null : +d));\n}\n\n/**\n * Encode simple objects as readable strings. Works only for simple,\n * flat objects where values are numbers, strings.\n *\n * For example { foo: bar, boo: baz } -> \"foo-bar_boo-baz\"\n *\n * @param {Object} object The object to encode\n * @param {String} keyValSeparator=\"-\" The separator between keys and values\n * @param {String} entrySeparator=\"_\" The separator between entries\n * @return {String} The encoded object\n */\nexport function encodeObject(\n  obj: { [key: string]: string | null | number | undefined } | null | undefined,\n  keyValSeparator = '-',\n  entrySeparator = '_'\n): string | null | undefined {\n  if (obj == null) return obj; // null or undefined\n  if (!Object.keys(obj).length) return ''; // {} case\n\n  return Object.keys(obj)\n    .map((key) => `${key}${keyValSeparator}${obj[key]}`)\n    .join(entrySeparator);\n}\n\n/**\n * Decodes a simple object to javascript. Currently works only for simple,\n * flat objects where values are strings.\n *\n * For example \"foo-bar_boo-baz\" -> { foo: bar, boo: baz }\n *\n * If an array is provided as input, only the first entry is used.\n *\n * @param {String} input The object string to decode\n * @param {String} keyValSeparator=\"-\" The separator between keys and values\n * @param {String} entrySeparator=\"_\" The separator between entries\n * @return {Object} The javascript object\n */\nexport function decodeObject(\n  input: string | (string | null)[] | null | undefined,\n  keyValSeparator = '-',\n  entrySeparator = '_'\n): { [key: string]: string } | null | undefined {\n  const objStr = getEncodedValue(input, true);\n  if (objStr == null) return objStr;\n  if (objStr === '') return {};\n\n  const obj: { [key: string]: string } = {};\n\n  const keyValSeparatorRegExp = new RegExp(`${keyValSeparator}(.*)`);\n  objStr.split(entrySeparator).forEach((entryStr) => {\n    const [key, value] = entryStr.split(keyValSeparatorRegExp);\n    obj[key] = value;\n  });\n\n  return obj;\n}\n\n/**\n * Encode simple objects as readable strings. Alias of encodeObject.\n *\n * For example { foo: 123, boo: 521 } -> \"foo-123_boo-521\"\n *\n * @param {Object} object The object to encode\n * @param {String} keyValSeparator=\"-\" The separator between keys and values\n * @param {String} entrySeparator=\"_\" The separator between entries\n * @return {String} The encoded object\n */\nexport const encodeNumericObject = encodeObject as (\n  obj: { [key: string]: number | null | undefined } | null | undefined,\n  keyValSeparator?: string,\n  entrySeparator?: string\n) => string | null | undefined;\n\n/**\n * Decodes a simple object to javascript where all values are numbers.\n * Currently works only for simple, flat objects.\n *\n * For example \"foo-123_boo-521\" -> { foo: 123, boo: 521 }\n *\n * If an array is provided as input, only the first entry is used.\n *\n * @param {String} input The object string to decode\n * @param {String} keyValSeparator=\"-\" The separator between keys and values\n * @param {String} entrySeparator=\"_\" The separator between entries\n * @return {Object} The javascript object\n */\nexport function decodeNumericObject(\n  input: string | (string | null)[] | null | undefined,\n  keyValSeparator = '-',\n  entrySeparator = '_'\n): { [key: string]: number | null | undefined } | null | undefined {\n  const decoded: { [key: string]: string } | null | undefined = decodeObject(\n    input,\n    keyValSeparator,\n    entrySeparator\n  );\n\n  if (decoded == null) return decoded;\n\n  // convert to numbers\n  const decodedNumberObj: { [key: string]: number | null | undefined } = {};\n  for (const key of Object.keys(decoded)) {\n    decodedNumberObj[key] = decodeNumber(decoded[key]);\n  }\n\n  return decodedNumberObj;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}