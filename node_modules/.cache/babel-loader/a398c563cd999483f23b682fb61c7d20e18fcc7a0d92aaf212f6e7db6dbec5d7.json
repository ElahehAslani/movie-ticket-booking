{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = splitExportDeclaration;\nvar _t = require(\"@babel/types\");\nconst {\n  cloneNode,\n  exportNamedDeclaration,\n  exportSpecifier,\n  identifier,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\nfunction splitExportDeclaration(exportDeclaration) {\n  if (!exportDeclaration.isExportDeclaration() || exportDeclaration.isExportAllDeclaration()) {\n    throw new Error(\"Only default and named export declarations can be split.\");\n  }\n  if (exportDeclaration.isExportDefaultDeclaration()) {\n    const declaration = exportDeclaration.get(\"declaration\");\n    const standaloneDeclaration = declaration.isFunctionDeclaration() || declaration.isClassDeclaration();\n    const scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;\n    let id = declaration.node.id;\n    let needBindingRegistration = false;\n    if (!id) {\n      needBindingRegistration = true;\n      id = scope.generateUidIdentifier(\"default\");\n      if (standaloneDeclaration || declaration.isFunctionExpression() || declaration.isClassExpression()) {\n        declaration.node.id = cloneNode(id);\n      }\n    }\n    const updatedDeclaration = standaloneDeclaration ? declaration.node : variableDeclaration(\"var\", [variableDeclarator(cloneNode(id), declaration.node)]);\n    const updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode(id), identifier(\"default\"))]);\n    exportDeclaration.insertAfter(updatedExportDeclaration);\n    exportDeclaration.replaceWith(updatedDeclaration);\n    if (needBindingRegistration) {\n      scope.registerDeclaration(exportDeclaration);\n    }\n    return exportDeclaration;\n  } else if (exportDeclaration.get(\"specifiers\").length > 0) {\n    throw new Error(\"It doesn't make sense to split exported specifiers.\");\n  }\n  const declaration = exportDeclaration.get(\"declaration\");\n  const bindingIdentifiers = declaration.getOuterBindingIdentifiers();\n  const specifiers = Object.keys(bindingIdentifiers).map(name => {\n    return exportSpecifier(identifier(name), identifier(name));\n  });\n  const aliasDeclar = exportNamedDeclaration(null, specifiers);\n  exportDeclaration.insertAfter(aliasDeclar);\n  exportDeclaration.replaceWith(declaration.node);\n  return exportDeclaration;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","splitExportDeclaration","_t","require","cloneNode","exportNamedDeclaration","exportSpecifier","identifier","variableDeclaration","variableDeclarator","exportDeclaration","isExportDeclaration","isExportAllDeclaration","Error","isExportDefaultDeclaration","declaration","get","standaloneDeclaration","isFunctionDeclaration","isClassDeclaration","scope","isScope","parent","id","node","needBindingRegistration","generateUidIdentifier","isFunctionExpression","isClassExpression","updatedDeclaration","updatedExportDeclaration","insertAfter","replaceWith","registerDeclaration","length","bindingIdentifiers","getOuterBindingIdentifiers","specifiers","keys","map","name","aliasDeclar"],"sources":["/Users/elahehaslani/Work/Sample-Project/ticket-booking/ticket-booking/node_modules/@babel/helper-split-export-declaration/lib/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = splitExportDeclaration;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  cloneNode,\n  exportNamedDeclaration,\n  exportSpecifier,\n  identifier,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\n\nfunction splitExportDeclaration(exportDeclaration) {\n  if (!exportDeclaration.isExportDeclaration() || exportDeclaration.isExportAllDeclaration()) {\n    throw new Error(\"Only default and named export declarations can be split.\");\n  }\n\n  if (exportDeclaration.isExportDefaultDeclaration()) {\n    const declaration = exportDeclaration.get(\"declaration\");\n    const standaloneDeclaration = declaration.isFunctionDeclaration() || declaration.isClassDeclaration();\n    const scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;\n    let id = declaration.node.id;\n    let needBindingRegistration = false;\n\n    if (!id) {\n      needBindingRegistration = true;\n      id = scope.generateUidIdentifier(\"default\");\n\n      if (standaloneDeclaration || declaration.isFunctionExpression() || declaration.isClassExpression()) {\n        declaration.node.id = cloneNode(id);\n      }\n    }\n\n    const updatedDeclaration = standaloneDeclaration ? declaration.node : variableDeclaration(\"var\", [variableDeclarator(cloneNode(id), declaration.node)]);\n    const updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode(id), identifier(\"default\"))]);\n    exportDeclaration.insertAfter(updatedExportDeclaration);\n    exportDeclaration.replaceWith(updatedDeclaration);\n\n    if (needBindingRegistration) {\n      scope.registerDeclaration(exportDeclaration);\n    }\n\n    return exportDeclaration;\n  } else if (exportDeclaration.get(\"specifiers\").length > 0) {\n    throw new Error(\"It doesn't make sense to split exported specifiers.\");\n  }\n\n  const declaration = exportDeclaration.get(\"declaration\");\n  const bindingIdentifiers = declaration.getOuterBindingIdentifiers();\n  const specifiers = Object.keys(bindingIdentifiers).map(name => {\n    return exportSpecifier(identifier(name), identifier(name));\n  });\n  const aliasDeclar = exportNamedDeclaration(null, specifiers);\n  exportDeclaration.insertAfter(aliasDeclar);\n  exportDeclaration.replaceWith(declaration.node);\n  return exportDeclaration;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}