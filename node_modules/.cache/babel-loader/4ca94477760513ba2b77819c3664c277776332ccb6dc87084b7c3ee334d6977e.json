{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = normalizeModuleAndLoadMetadata;\nexports.hasExports = hasExports;\nexports.isSideEffectImport = isSideEffectImport;\nexports.validateImportInteropOption = validateImportInteropOption;\nvar _path = require(\"path\");\nvar _helperValidatorIdentifier = require(\"@babel/helper-validator-identifier\");\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\nfunction hasExports(metadata) {\n  return metadata.hasExports;\n}\nfunction isSideEffectImport(source) {\n  return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;\n}\nfunction validateImportInteropOption(importInterop) {\n  if (typeof importInterop !== \"function\" && importInterop !== \"none\" && importInterop !== \"babel\" && importInterop !== \"node\") {\n    throw new Error(`.importInterop must be one of \"none\", \"babel\", \"node\", or a function returning one of those values (received ${importInterop}).`);\n  }\n  return importInterop;\n}\nfunction resolveImportInterop(importInterop, source, filename) {\n  if (typeof importInterop === \"function\") {\n    return validateImportInteropOption(importInterop(source, filename));\n  }\n  return importInterop;\n}\nfunction normalizeModuleAndLoadMetadata(programPath, exportName, _ref) {\n  let {\n    importInterop,\n    initializeReexports = false,\n    lazy = false,\n    esNamespaceOnly = false,\n    filename\n  } = _ref;\n  if (!exportName) {\n    exportName = programPath.scope.generateUidIdentifier(\"exports\").name;\n  }\n  const stringSpecifiers = new Set();\n  nameAnonymousExports(programPath);\n  const {\n    local,\n    source,\n    hasExports\n  } = getModuleMetadata(programPath, {\n    initializeReexports,\n    lazy\n  }, stringSpecifiers);\n  removeImportExportDeclarations(programPath);\n  for (const [, metadata] of source) {\n    if (metadata.importsNamespace.size > 0) {\n      metadata.name = metadata.importsNamespace.values().next().value;\n    }\n    const resolvedInterop = resolveImportInterop(importInterop, metadata.source, filename);\n    if (resolvedInterop === \"none\") {\n      metadata.interop = \"none\";\n    } else if (resolvedInterop === \"node\" && metadata.interop === \"namespace\") {\n      metadata.interop = \"node-namespace\";\n    } else if (resolvedInterop === \"node\" && metadata.interop === \"default\") {\n      metadata.interop = \"node-default\";\n    } else if (esNamespaceOnly && metadata.interop === \"namespace\") {\n      metadata.interop = \"default\";\n    }\n  }\n  return {\n    exportName,\n    exportNameListName: null,\n    hasExports,\n    local,\n    source,\n    stringSpecifiers\n  };\n}\nfunction getExportSpecifierName(path, stringSpecifiers) {\n  if (path.isIdentifier()) {\n    return path.node.name;\n  } else if (path.isStringLiteral()) {\n    const stringValue = path.node.value;\n    if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {\n      stringSpecifiers.add(stringValue);\n    }\n    return stringValue;\n  } else {\n    throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`);\n  }\n}\nfunction assertExportSpecifier(path) {\n  if (path.isExportSpecifier()) {\n    return;\n  } else if (path.isExportNamespaceSpecifier()) {\n    throw path.buildCodeFrameError(\"Export namespace should be first transformed by `@babel/plugin-proposal-export-namespace-from`.\");\n  } else {\n    throw path.buildCodeFrameError(\"Unexpected export specifier type\");\n  }\n}\nfunction getModuleMetadata(programPath, _ref2, stringSpecifiers) {\n  let {\n    lazy,\n    initializeReexports\n  } = _ref2;\n  const localData = getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers);\n  const sourceData = new Map();\n  const getData = sourceNode => {\n    const source = sourceNode.value;\n    let data = sourceData.get(source);\n    if (!data) {\n      data = {\n        name: programPath.scope.generateUidIdentifier((0, _path.basename)(source, (0, _path.extname)(source))).name,\n        interop: \"none\",\n        loc: null,\n        imports: new Map(),\n        importsNamespace: new Set(),\n        reexports: new Map(),\n        reexportNamespace: new Set(),\n        reexportAll: null,\n        lazy: false,\n        source\n      };\n      sourceData.set(source, data);\n    }\n    return data;\n  };\n  let hasExports = false;\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n      child.get(\"specifiers\").forEach(spec => {\n        if (spec.isImportDefaultSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n          data.imports.set(localName, \"default\");\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n            reexport.names.forEach(name => {\n              data.reexports.set(name, \"default\");\n            });\n          }\n        } else if (spec.isImportNamespaceSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n          data.importsNamespace.add(localName);\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n            reexport.names.forEach(name => {\n              data.reexportNamespace.add(name);\n            });\n          }\n        } else if (spec.isImportSpecifier()) {\n          const importName = getExportSpecifierName(spec.get(\"imported\"), stringSpecifiers);\n          const localName = spec.get(\"local\").node.name;\n          data.imports.set(localName, importName);\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n            reexport.names.forEach(name => {\n              data.reexports.set(name, importName);\n            });\n          }\n        }\n      });\n    } else if (child.isExportAllDeclaration()) {\n      hasExports = true;\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n      data.reexportAll = {\n        loc: child.node.loc\n      };\n    } else if (child.isExportNamedDeclaration() && child.node.source) {\n      hasExports = true;\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n      child.get(\"specifiers\").forEach(spec => {\n        assertExportSpecifier(spec);\n        const importName = getExportSpecifierName(spec.get(\"local\"), stringSpecifiers);\n        const exportName = getExportSpecifierName(spec.get(\"exported\"), stringSpecifiers);\n        data.reexports.set(exportName, importName);\n        if (exportName === \"__esModule\") {\n          throw spec.get(\"exported\").buildCodeFrameError('Illegal export \"__esModule\".');\n        }\n      });\n    } else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) {\n      hasExports = true;\n    }\n  });\n  for (const metadata of sourceData.values()) {\n    let needsDefault = false;\n    let needsNamed = false;\n    if (metadata.importsNamespace.size > 0) {\n      needsDefault = true;\n      needsNamed = true;\n    }\n    if (metadata.reexportAll) {\n      needsNamed = true;\n    }\n    for (const importName of metadata.imports.values()) {\n      if (importName === \"default\") needsDefault = true;else needsNamed = true;\n    }\n    for (const importName of metadata.reexports.values()) {\n      if (importName === \"default\") needsDefault = true;else needsNamed = true;\n    }\n    if (needsDefault && needsNamed) {\n      metadata.interop = \"namespace\";\n    } else if (needsDefault) {\n      metadata.interop = \"default\";\n    }\n  }\n  for (const [source, metadata] of sourceData) {\n    if (lazy !== false && !(isSideEffectImport(metadata) || metadata.reexportAll)) {\n      if (lazy === true) {\n        metadata.lazy = !/\\./.test(source);\n      } else if (Array.isArray(lazy)) {\n        metadata.lazy = lazy.indexOf(source) !== -1;\n      } else if (typeof lazy === \"function\") {\n        metadata.lazy = lazy(source);\n      } else {\n        throw new Error(`.lazy must be a boolean, string array, or function`);\n      }\n    }\n  }\n  return {\n    hasExports,\n    local: localData,\n    source: sourceData\n  };\n}\nfunction getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers) {\n  const bindingKindLookup = new Map();\n  programPath.get(\"body\").forEach(child => {\n    let kind;\n    if (child.isImportDeclaration()) {\n      kind = \"import\";\n    } else {\n      if (child.isExportDefaultDeclaration()) {\n        child = child.get(\"declaration\");\n      }\n      if (child.isExportNamedDeclaration()) {\n        if (child.node.declaration) {\n          child = child.get(\"declaration\");\n        } else if (initializeReexports && child.node.source && child.get(\"source\").isStringLiteral()) {\n          child.get(\"specifiers\").forEach(spec => {\n            assertExportSpecifier(spec);\n            bindingKindLookup.set(spec.get(\"local\").node.name, \"block\");\n          });\n          return;\n        }\n      }\n      if (child.isFunctionDeclaration()) {\n        kind = \"hoisted\";\n      } else if (child.isClassDeclaration()) {\n        kind = \"block\";\n      } else if (child.isVariableDeclaration({\n        kind: \"var\"\n      })) {\n        kind = \"var\";\n      } else if (child.isVariableDeclaration()) {\n        kind = \"block\";\n      } else {\n        return;\n      }\n    }\n    Object.keys(child.getOuterBindingIdentifiers()).forEach(name => {\n      bindingKindLookup.set(name, kind);\n    });\n  });\n  const localMetadata = new Map();\n  const getLocalMetadata = idPath => {\n    const localName = idPath.node.name;\n    let metadata = localMetadata.get(localName);\n    if (!metadata) {\n      const kind = bindingKindLookup.get(localName);\n      if (kind === undefined) {\n        throw idPath.buildCodeFrameError(`Exporting local \"${localName}\", which is not declared.`);\n      }\n      metadata = {\n        names: [],\n        kind\n      };\n      localMetadata.set(localName, metadata);\n    }\n    return metadata;\n  };\n  programPath.get(\"body\").forEach(child => {\n    if (child.isExportNamedDeclaration() && (initializeReexports || !child.node.source)) {\n      if (child.node.declaration) {\n        const declaration = child.get(\"declaration\");\n        const ids = declaration.getOuterBindingIdentifierPaths();\n        Object.keys(ids).forEach(name => {\n          if (name === \"__esModule\") {\n            throw declaration.buildCodeFrameError('Illegal export \"__esModule\".');\n          }\n          getLocalMetadata(ids[name]).names.push(name);\n        });\n      } else {\n        child.get(\"specifiers\").forEach(spec => {\n          const local = spec.get(\"local\");\n          const exported = spec.get(\"exported\");\n          const localMetadata = getLocalMetadata(local);\n          const exportName = getExportSpecifierName(exported, stringSpecifiers);\n          if (exportName === \"__esModule\") {\n            throw exported.buildCodeFrameError('Illegal export \"__esModule\".');\n          }\n          localMetadata.names.push(exportName);\n        });\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      const declaration = child.get(\"declaration\");\n      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {\n        getLocalMetadata(declaration.get(\"id\")).names.push(\"default\");\n      } else {\n        throw declaration.buildCodeFrameError(\"Unexpected default expression export.\");\n      }\n    }\n  });\n  return localMetadata;\n}\nfunction nameAnonymousExports(programPath) {\n  programPath.get(\"body\").forEach(child => {\n    if (!child.isExportDefaultDeclaration()) return;\n    (0, _helperSplitExportDeclaration.default)(child);\n  });\n}\nfunction removeImportExportDeclarations(programPath) {\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      child.remove();\n    } else if (child.isExportNamedDeclaration()) {\n      if (child.node.declaration) {\n        child.node.declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(child.node.declaration);\n      } else {\n        child.remove();\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      const declaration = child.get(\"declaration\");\n      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {\n        declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(declaration);\n      } else {\n        throw declaration.buildCodeFrameError(\"Unexpected default expression export.\");\n      }\n    } else if (child.isExportAllDeclaration()) {\n      child.remove();\n    }\n  });\n}","map":{"version":3,"mappings":"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","names":["hasExports","metadata","isSideEffectImport","source","imports","size","importsNamespace","reexports","reexportNamespace","reexportAll","validateImportInteropOption","importInterop","Error","resolveImportInterop","filename","normalizeModuleAndLoadMetadata","programPath","exportName","initializeReexports","lazy","esNamespaceOnly","scope","generateUidIdentifier","name","stringSpecifiers","Set","nameAnonymousExports","local","getModuleMetadata","removeImportExportDeclarations","values","next","value","resolvedInterop","interop","exportNameListName","getExportSpecifierName","path","isIdentifier","node","isStringLiteral","stringValue","add","type","assertExportSpecifier","isExportSpecifier","isExportNamespaceSpecifier","buildCodeFrameError","localData","getLocalExportMetadata","sourceData","Map","getData","sourceNode","data","get","loc","set","forEach","child","isImportDeclaration","spec","isImportDefaultSpecifier","localName","reexport","delete","names","isImportNamespaceSpecifier","isImportSpecifier","importName","isExportAllDeclaration","isExportNamedDeclaration","isExportDefaultDeclaration","needsDefault","needsNamed","test","Array","isArray","indexOf","bindingKindLookup","kind","declaration","isFunctionDeclaration","isClassDeclaration","isVariableDeclaration","Object","keys","getOuterBindingIdentifiers","localMetadata","getLocalMetadata","idPath","undefined","ids","getOuterBindingIdentifierPaths","push","exported","remove","_blockHoist","replaceWith"],"sources":["/Users/elahehaslani/Work/Sample-Project/ticket-booking/ticket-booking/node_modules/@babel/helper-module-transforms/src/normalize-and-load-metadata.ts"],"sourcesContent":["import { basename, extname } from \"path\";\nimport type * as t from \"@babel/types\";\n\nimport { isIdentifierName } from \"@babel/helper-validator-identifier\";\nimport splitExportDeclaration from \"@babel/helper-split-export-declaration\";\nimport type { NodePath } from \"@babel/traverse\";\n\nexport interface ModuleMetadata {\n  exportName: string;\n  // The name of the variable that will reference an object containing export names.\n  exportNameListName: null | string;\n  hasExports: boolean;\n  // Lookup from local binding to export information.\n  local: Map<string, LocalExportMetadata>;\n  // Lookup of source file to source file metadata.\n  source: Map<string, SourceModuleMetadata>;\n  // List of names that should only be printed as string literals.\n  // i.e. `import { \"any unicode\" as foo } from \"some-module\"`\n  // `stringSpecifiers` is Set(1) [\"any unicode\"]\n  // In most cases `stringSpecifiers` is an empty Set\n  stringSpecifiers: Set<string>;\n}\n\nexport type InteropType =\n  | \"default\" // Babel interop for default-only imports\n  | \"namespace\" // Babel interop for namespace or default+named imports\n  | \"node-default\" // Node.js interop for default-only imports\n  | \"node-namespace\" // Node.js interop for namespace or default+named imports\n  | \"none\"; // No interop, or named-only imports\n\nexport type ImportInterop =\n  | \"none\"\n  | \"babel\"\n  | \"node\"\n  | ((source: string, filename?: string) => \"none\" | \"babel\" | \"node\");\n\nexport type Lazy = boolean | string[] | ((source: string) => boolean);\n\nexport interface SourceModuleMetadata {\n  // A unique variable name to use for this namespace object. Centralized for simplicity.\n  name: string;\n  loc: t.SourceLocation | undefined | null;\n  interop: InteropType;\n  // Local binding to reference from this source namespace. Key: Local name, value: Import name\n  imports: Map<string, string>;\n  // Local names that reference namespace object.\n  importsNamespace: Set<string>;\n  // Reexports to create for namespace. Key: Export name, value: Import name\n  reexports: Map<string, string>;\n  // List of names to re-export namespace as.\n  reexportNamespace: Set<string>;\n  // Tracks if the source should be re-exported.\n  reexportAll: null | {\n    loc: t.SourceLocation | undefined | null;\n  };\n  lazy?: Lazy;\n}\n\nexport interface LocalExportMetadata {\n  names: Array<string>; // names of exports,\n  kind: \"import\" | \"hoisted\" | \"block\" | \"var\";\n}\n\n/**\n * Check if the module has any exports that need handling.\n */\nexport function hasExports(metadata: ModuleMetadata) {\n  return metadata.hasExports;\n}\n\n/**\n * Check if a given source is an anonymous import, e.g. \"import 'foo';\"\n */\nexport function isSideEffectImport(source: SourceModuleMetadata) {\n  return (\n    source.imports.size === 0 &&\n    source.importsNamespace.size === 0 &&\n    source.reexports.size === 0 &&\n    source.reexportNamespace.size === 0 &&\n    !source.reexportAll\n  );\n}\n\nexport function validateImportInteropOption(\n  importInterop: any,\n): importInterop is ImportInterop {\n  if (\n    typeof importInterop !== \"function\" &&\n    importInterop !== \"none\" &&\n    importInterop !== \"babel\" &&\n    importInterop !== \"node\"\n  ) {\n    throw new Error(\n      `.importInterop must be one of \"none\", \"babel\", \"node\", or a function returning one of those values (received ${importInterop}).`,\n    );\n  }\n  return importInterop;\n}\n\nfunction resolveImportInterop(\n  importInterop: ImportInterop,\n  source: string,\n  filename: string | undefined,\n) {\n  if (typeof importInterop === \"function\") {\n    return validateImportInteropOption(importInterop(source, filename));\n  }\n  return importInterop;\n}\n\n/**\n * Remove all imports and exports from the file, and return all metadata\n * needed to reconstruct the module's behavior.\n */\nexport default function normalizeModuleAndLoadMetadata(\n  programPath: NodePath<t.Program>,\n  exportName: string,\n  {\n    importInterop,\n    initializeReexports = false,\n    lazy = false,\n    esNamespaceOnly = false,\n    filename,\n  }: {\n    importInterop: ImportInterop;\n    initializeReexports: boolean | void;\n    lazy: Lazy;\n    esNamespaceOnly: boolean;\n    filename: string;\n  },\n): ModuleMetadata {\n  if (!exportName) {\n    exportName = programPath.scope.generateUidIdentifier(\"exports\").name;\n  }\n  const stringSpecifiers = new Set<string>();\n\n  nameAnonymousExports(programPath);\n\n  const { local, source, hasExports } = getModuleMetadata(\n    programPath,\n    { initializeReexports, lazy },\n    stringSpecifiers,\n  );\n\n  removeImportExportDeclarations(programPath);\n\n  // Reuse the imported namespace name if there is one.\n  for (const [, metadata] of source) {\n    if (metadata.importsNamespace.size > 0) {\n      // This is kind of gross. If we stop using `loose: true` we should\n      // just make this destructuring assignment.\n      metadata.name = metadata.importsNamespace.values().next().value;\n    }\n\n    const resolvedInterop = resolveImportInterop(\n      importInterop,\n      metadata.source,\n      filename,\n    );\n\n    if (resolvedInterop === \"none\") {\n      metadata.interop = \"none\";\n    } else if (resolvedInterop === \"node\" && metadata.interop === \"namespace\") {\n      metadata.interop = \"node-namespace\";\n    } else if (resolvedInterop === \"node\" && metadata.interop === \"default\") {\n      metadata.interop = \"node-default\";\n    } else if (esNamespaceOnly && metadata.interop === \"namespace\") {\n      // Both the default and namespace interops pass through __esModule\n      // objects, but the namespace interop is used to enable Babel's\n      // destructuring-like interop behavior for normal CommonJS.\n      // Since some tooling has started to remove that behavior, we expose\n      // it as the `esNamespace` option.\n      metadata.interop = \"default\";\n    }\n  }\n\n  return {\n    exportName,\n    exportNameListName: null,\n    hasExports,\n    local,\n    source,\n    stringSpecifiers,\n  };\n}\n\nfunction getExportSpecifierName(\n  path: NodePath,\n  stringSpecifiers: Set<string>,\n): string {\n  if (path.isIdentifier()) {\n    return path.node.name;\n  } else if (path.isStringLiteral()) {\n    const stringValue = path.node.value;\n    // add specifier value to `stringSpecifiers` only when it can not be converted to an identifier name\n    // i.e In `import { \"foo\" as bar }`\n    // we do not consider `\"foo\"` to be a `stringSpecifier` because we can treat it as\n    // `import { foo as bar }`\n    // This helps minimize the size of `stringSpecifiers` and reduce overhead of checking valid identifier names\n    // when building transpiled code from metadata\n    if (!isIdentifierName(stringValue)) {\n      stringSpecifiers.add(stringValue);\n    }\n    return stringValue;\n  } else {\n    throw new Error(\n      `Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type}`,\n    );\n  }\n}\n\nfunction assertExportSpecifier(\n  path: NodePath,\n): asserts path is NodePath<t.ExportSpecifier> {\n  if (path.isExportSpecifier()) {\n    return;\n  } else if (path.isExportNamespaceSpecifier()) {\n    throw path.buildCodeFrameError(\n      \"Export namespace should be first transformed by `@babel/plugin-proposal-export-namespace-from`.\",\n    );\n  } else {\n    throw path.buildCodeFrameError(\"Unexpected export specifier type\");\n  }\n}\n\n/**\n * Get metadata about the imports and exports present in this module.\n */\nfunction getModuleMetadata(\n  programPath: NodePath<t.Program>,\n  {\n    lazy,\n    initializeReexports,\n  }: {\n    // todo(flow-ts) changed from boolean, to match expected usage inside the function\n    lazy: boolean | string[] | ((source: string) => boolean);\n    initializeReexports: boolean | void;\n  },\n  stringSpecifiers: Set<string>,\n) {\n  const localData = getLocalExportMetadata(\n    programPath,\n    initializeReexports,\n    stringSpecifiers,\n  );\n\n  const sourceData = new Map();\n  const getData = (sourceNode: t.StringLiteral) => {\n    const source = sourceNode.value;\n\n    let data = sourceData.get(source);\n    if (!data) {\n      data = {\n        name: programPath.scope.generateUidIdentifier(\n          basename(source, extname(source)),\n        ).name,\n\n        interop: \"none\",\n\n        loc: null,\n\n        // Data about the requested sources and names.\n        imports: new Map(),\n        importsNamespace: new Set(),\n\n        // Metadata about data that is passed directly from source to export.\n        reexports: new Map(),\n        reexportNamespace: new Set(),\n        reexportAll: null,\n\n        lazy: false,\n\n        source,\n      };\n      sourceData.set(source, data);\n    }\n    return data;\n  };\n  let hasExports = false;\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n\n      child.get(\"specifiers\").forEach(spec => {\n        if (spec.isImportDefaultSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n\n          data.imports.set(localName, \"default\");\n\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n\n            reexport.names.forEach(name => {\n              data.reexports.set(name, \"default\");\n            });\n          }\n        } else if (spec.isImportNamespaceSpecifier()) {\n          const localName = spec.get(\"local\").node.name;\n\n          data.importsNamespace.add(localName);\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n\n            reexport.names.forEach(name => {\n              data.reexportNamespace.add(name);\n            });\n          }\n        } else if (spec.isImportSpecifier()) {\n          const importName = getExportSpecifierName(\n            spec.get(\"imported\"),\n            stringSpecifiers,\n          );\n          const localName = spec.get(\"local\").node.name;\n\n          data.imports.set(localName, importName);\n\n          const reexport = localData.get(localName);\n          if (reexport) {\n            localData.delete(localName);\n\n            reexport.names.forEach(name => {\n              data.reexports.set(name, importName);\n            });\n          }\n        }\n      });\n    } else if (child.isExportAllDeclaration()) {\n      hasExports = true;\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n\n      data.reexportAll = {\n        loc: child.node.loc,\n      };\n    } else if (child.isExportNamedDeclaration() && child.node.source) {\n      hasExports = true;\n      const data = getData(child.node.source);\n      if (!data.loc) data.loc = child.node.loc;\n\n      child.get(\"specifiers\").forEach(spec => {\n        assertExportSpecifier(spec);\n        const importName = getExportSpecifierName(\n          spec.get(\"local\"),\n          stringSpecifiers,\n        );\n        const exportName = getExportSpecifierName(\n          spec.get(\"exported\"),\n          stringSpecifiers,\n        );\n\n        data.reexports.set(exportName, importName);\n\n        if (exportName === \"__esModule\") {\n          throw spec\n            .get(\"exported\")\n            .buildCodeFrameError('Illegal export \"__esModule\".');\n        }\n      });\n    } else if (\n      child.isExportNamedDeclaration() ||\n      child.isExportDefaultDeclaration()\n    ) {\n      hasExports = true;\n    }\n  });\n\n  for (const metadata of sourceData.values()) {\n    let needsDefault = false;\n    let needsNamed = false;\n\n    if (metadata.importsNamespace.size > 0) {\n      needsDefault = true;\n      needsNamed = true;\n    }\n\n    if (metadata.reexportAll) {\n      needsNamed = true;\n    }\n\n    for (const importName of metadata.imports.values()) {\n      if (importName === \"default\") needsDefault = true;\n      else needsNamed = true;\n    }\n    for (const importName of metadata.reexports.values()) {\n      if (importName === \"default\") needsDefault = true;\n      else needsNamed = true;\n    }\n\n    if (needsDefault && needsNamed) {\n      // TODO(logan): Using the namespace interop here is unfortunate. Revisit.\n      metadata.interop = \"namespace\";\n    } else if (needsDefault) {\n      metadata.interop = \"default\";\n    }\n  }\n\n  for (const [source, metadata] of sourceData) {\n    if (\n      lazy !== false &&\n      !(isSideEffectImport(metadata) || metadata.reexportAll)\n    ) {\n      if (lazy === true) {\n        // 'true' means that local relative files are eagerly loaded and\n        // dependency modules are loaded lazily.\n        metadata.lazy = !/\\./.test(source);\n      } else if (Array.isArray(lazy)) {\n        metadata.lazy = lazy.indexOf(source) !== -1;\n      } else if (typeof lazy === \"function\") {\n        metadata.lazy = lazy(source);\n      } else {\n        throw new Error(`.lazy must be a boolean, string array, or function`);\n      }\n    }\n  }\n\n  return {\n    hasExports,\n    local: localData,\n    source: sourceData,\n  };\n}\n\ntype ModuleBindingKind = \"import\" | \"hoisted\" | \"block\" | \"var\";\n/**\n * Get metadata about local variables that are exported.\n */\nfunction getLocalExportMetadata(\n  programPath: NodePath<t.Program>,\n  initializeReexports: boolean | void,\n  stringSpecifiers: Set<string>,\n): Map<string, LocalExportMetadata> {\n  const bindingKindLookup = new Map();\n\n  programPath.get(\"body\").forEach((child: NodePath) => {\n    let kind: ModuleBindingKind;\n    if (child.isImportDeclaration()) {\n      kind = \"import\";\n    } else {\n      if (child.isExportDefaultDeclaration()) {\n        child = child.get(\"declaration\");\n      }\n      if (child.isExportNamedDeclaration()) {\n        if (child.node.declaration) {\n          child = child.get(\"declaration\");\n        } else if (\n          initializeReexports &&\n          child.node.source &&\n          child.get(\"source\").isStringLiteral()\n        ) {\n          child.get(\"specifiers\").forEach(spec => {\n            assertExportSpecifier(spec);\n            bindingKindLookup.set(spec.get(\"local\").node.name, \"block\");\n          });\n          return;\n        }\n      }\n\n      if (child.isFunctionDeclaration()) {\n        kind = \"hoisted\";\n      } else if (child.isClassDeclaration()) {\n        kind = \"block\";\n      } else if (child.isVariableDeclaration({ kind: \"var\" })) {\n        kind = \"var\";\n      } else if (child.isVariableDeclaration()) {\n        kind = \"block\";\n      } else {\n        return;\n      }\n    }\n\n    Object.keys(child.getOuterBindingIdentifiers()).forEach(name => {\n      bindingKindLookup.set(name, kind);\n    });\n  });\n\n  const localMetadata = new Map();\n  const getLocalMetadata = (idPath: NodePath<t.Identifier>) => {\n    const localName = idPath.node.name;\n    let metadata = localMetadata.get(localName);\n\n    if (!metadata) {\n      const kind = bindingKindLookup.get(localName);\n\n      if (kind === undefined) {\n        throw idPath.buildCodeFrameError(\n          `Exporting local \"${localName}\", which is not declared.`,\n        );\n      }\n\n      metadata = {\n        names: [],\n        kind,\n      };\n      localMetadata.set(localName, metadata);\n    }\n    return metadata;\n  };\n\n  programPath.get(\"body\").forEach(child => {\n    if (\n      child.isExportNamedDeclaration() &&\n      (initializeReexports || !child.node.source)\n    ) {\n      if (child.node.declaration) {\n        const declaration = child.get(\"declaration\");\n        const ids = declaration.getOuterBindingIdentifierPaths();\n        Object.keys(ids).forEach(name => {\n          if (name === \"__esModule\") {\n            throw declaration.buildCodeFrameError(\n              'Illegal export \"__esModule\".',\n            );\n          }\n          getLocalMetadata(ids[name]).names.push(name);\n        });\n      } else {\n        child.get(\"specifiers\").forEach(spec => {\n          const local = spec.get(\"local\");\n          const exported = spec.get(\"exported\");\n          const localMetadata = getLocalMetadata(local);\n          const exportName = getExportSpecifierName(exported, stringSpecifiers);\n\n          if (exportName === \"__esModule\") {\n            throw exported.buildCodeFrameError('Illegal export \"__esModule\".');\n          }\n          localMetadata.names.push(exportName);\n        });\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      const declaration = child.get(\"declaration\");\n      if (\n        declaration.isFunctionDeclaration() ||\n        declaration.isClassDeclaration()\n      ) {\n        // @ts-expect-error todo(flow->ts): improve babel-types\n        getLocalMetadata(declaration.get(\"id\")).names.push(\"default\");\n      } else {\n        // These should have been removed by the nameAnonymousExports() call.\n        throw declaration.buildCodeFrameError(\n          \"Unexpected default expression export.\",\n        );\n      }\n    }\n  });\n  return localMetadata;\n}\n\n/**\n * Ensure that all exported values have local binding names.\n */\nfunction nameAnonymousExports(programPath: NodePath<t.Program>) {\n  // Name anonymous exported locals.\n  programPath.get(\"body\").forEach(child => {\n    if (!child.isExportDefaultDeclaration()) return;\n    splitExportDeclaration(child);\n  });\n}\n\nfunction removeImportExportDeclarations(programPath: NodePath<t.Program>) {\n  programPath.get(\"body\").forEach(child => {\n    if (child.isImportDeclaration()) {\n      child.remove();\n    } else if (child.isExportNamedDeclaration()) {\n      if (child.node.declaration) {\n        // @ts-expect-error todo(flow->ts): avoid mutations\n        child.node.declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(child.node.declaration);\n      } else {\n        child.remove();\n      }\n    } else if (child.isExportDefaultDeclaration()) {\n      // export default foo;\n      const declaration = child.get(\"declaration\");\n      if (\n        declaration.isFunctionDeclaration() ||\n        declaration.isClassDeclaration()\n      ) {\n        // @ts-expect-error todo(flow->ts): avoid mutations\n        declaration._blockHoist = child.node._blockHoist;\n        child.replaceWith(\n          declaration as NodePath<t.FunctionDeclaration | t.ClassDeclaration>,\n        );\n      } else {\n        // These should have been removed by the nameAnonymousExports() call.\n        throw declaration.buildCodeFrameError(\n          \"Unexpected default expression export.\",\n        );\n      }\n    } else if (child.isExportAllDeclaration()) {\n      child.remove();\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}