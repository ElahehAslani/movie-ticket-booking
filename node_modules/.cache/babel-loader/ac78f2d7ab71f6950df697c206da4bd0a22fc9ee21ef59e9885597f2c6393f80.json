{"ast":null,"code":"import { StringParam } from \"serialize-query-params\";\nfunction convertInheritedParamStringsToParams(paramConfigMapWithInherit, options) {\n  var _a, _b, _c;\n  const paramConfigMap = {};\n  let hasInherit = false;\n  const hookKeys = Object.keys(paramConfigMapWithInherit);\n  let paramKeys = hookKeys;\n  const includeKnownParams = options.includeKnownParams || options.includeKnownParams !== false && hookKeys.length === 0;\n  if (includeKnownParams) {\n    const knownKeys = Object.keys((_a = options.params) != null ? _a : {});\n    paramKeys.push(...knownKeys);\n  }\n  for (const key of paramKeys) {\n    const param = paramConfigMapWithInherit[key];\n    if (param != null && typeof param === \"object\") {\n      paramConfigMap[key] = param;\n      continue;\n    }\n    hasInherit = true;\n    paramConfigMap[key] = (_c = (_b = options.params) == null ? void 0 : _b[key]) != null ? _c : StringParam;\n  }\n  if (!hasInherit) return paramConfigMapWithInherit;\n  return paramConfigMap;\n}\nfunction extendParamConfigForKeys(baseParamConfigMap, paramKeys, inheritedParams, defaultParam) {\n  var _a;\n  if (!inheritedParams || !paramKeys.length) return baseParamConfigMap;\n  let paramConfigMap = {\n    ...baseParamConfigMap\n  };\n  let hasInherit = false;\n  for (const paramKey of paramKeys) {\n    if (!Object.prototype.hasOwnProperty.call(paramConfigMap, paramKey)) {\n      paramConfigMap[paramKey] = (_a = inheritedParams[paramKey]) != null ? _a : defaultParam;\n      hasInherit = true;\n    }\n  }\n  if (!hasInherit) return baseParamConfigMap;\n  return paramConfigMap;\n}\nexport { convertInheritedParamStringsToParams, extendParamConfigForKeys };","map":{"version":3,"mappings":"AAAA,SAGEA,mBACK;AASA,SAASC,qCACdC,2BACAC,SACqB;EAhBvB;EAiBE,MAAMC,iBAAsC,CAAC;EAC7C,IAAIC,aAAa;EAEjB,MAAMC,WAAWC,OAAOC,KAAKN,yBAAyB;EACtD,IAAIO,YAAYH;EAIhB,MAAMI,qBACJP,QAAQO,sBACPP,QAAQO,uBAAuB,SAASJ,SAASK,WAAW;EAE/D,IAAID,oBAAoB;IACtB,MAAME,YAAYL,OAAOC,MAAKK,aAAQC,WAAR,YAAkB,CAAC,CAAC;IAClDL,UAAUM,KAAK,GAAGH,SAAS;EAC7B;EAEA,WAAWI,OAAOP,WAAW;IAC3B,MAAMQ,QAAQf,0BAA0Bc;IAExC,IAAIC,SAAS,QAAQ,OAAOA,UAAU,UAAU;MAC9Cb,eAAeY,OAAOC;MACtB;IACF;IAGAZ,aAAa;IAGbD,eAAeY,QAAOE,mBAAQJ,WAAR,mBAAiBE,SAAjB,YAAyBhB;EACjD;EAGA,IAAI,CAACK,YAAY,OAAOH;EAExB,OAAOE;AACT;AAOO,SAASe,yBACdC,oBACAX,WACAY,iBACAC,cACA;EAjEF;EAmEE,IAAI,CAACD,mBAAmB,CAACZ,UAAUE,QAAQ,OAAOS;EAElD,IAAIhB,iBAAiB;IAAE,GAAGgB;EAAmB;EAC7C,IAAIf,aAAa;EACjB,WAAWkB,YAAYd,WAAW;IAEhC,IAAI,CAACF,OAAOiB,UAAUC,eAAeC,KAAKtB,gBAAgBmB,QAAQ,GAAG;MACnEnB,eAAemB,aAAYV,qBAAgBU,cAAhB,YAA6BD;MACxDjB,aAAa;IACf;EACF;EAEA,IAAI,CAACA,YAAY,OAAOe;EACxB,OAAOhB;AACT","names":["StringParam","convertInheritedParamStringsToParams","paramConfigMapWithInherit","options","paramConfigMap","hasInherit","hookKeys","Object","keys","paramKeys","includeKnownParams","length","knownKeys","_a","params","push","key","param","_c","extendParamConfigForKeys","baseParamConfigMap","inheritedParams","defaultParam","paramKey","prototype","hasOwnProperty","call"],"sources":["/Users/elahehaslani/Documents/GitHub/movie-ticket-booking/node_modules/use-query-params/src/inheritedParams.ts"],"sourcesContent":["import {\n  QueryParamConfig,\n  QueryParamConfigMap,\n  StringParam,\n} from 'serialize-query-params';\nimport { QueryParamOptions } from './options';\nimport { QueryParamConfigMapWithInherit } from './types';\n\n/**\n * Convert inherit strings from a query param config to actual\n * parameters based on predefined ('inherited') mappings.\n * Defaults to StringParam.\n */\nexport function convertInheritedParamStringsToParams(\n  paramConfigMapWithInherit: QueryParamConfigMapWithInherit,\n  options: QueryParamOptions\n): QueryParamConfigMap {\n  const paramConfigMap: QueryParamConfigMap = {};\n  let hasInherit = false;\n\n  const hookKeys = Object.keys(paramConfigMapWithInherit);\n  let paramKeys = hookKeys;\n\n  // include known params if asked for explicitly, or no params were configured and we didn't\n  // explicitly say not to\n  const includeKnownParams =\n    options.includeKnownParams ||\n    (options.includeKnownParams !== false && hookKeys.length === 0);\n\n  if (includeKnownParams) {\n    const knownKeys = Object.keys(options.params ?? {});\n    paramKeys.push(...knownKeys);\n  }\n\n  for (const key of paramKeys) {\n    const param = paramConfigMapWithInherit[key];\n    // does it have an existing parameter definition? use it\n    if (param != null && typeof param === 'object') {\n      paramConfigMap[key] = param;\n      continue;\n    }\n\n    // otherwise, we have to inherit or use the default\n    hasInherit = true;\n\n    // default is StringParam\n    paramConfigMap[key] = options.params?.[key] ?? StringParam;\n  }\n\n  // if we didn't inherit anything, just return the input\n  if (!hasInherit) return paramConfigMapWithInherit as QueryParamConfigMap;\n\n  return paramConfigMap;\n}\n\n/**\n * Extends a config to include params for all specified keys,\n * defaulting to StringParam if not found in the inheritedParams\n * map.\n */\nexport function extendParamConfigForKeys(\n  baseParamConfigMap: QueryParamConfigMap,\n  paramKeys: string[],\n  inheritedParams?: QueryParamOptions['params'] | undefined,\n  defaultParam?: QueryParamConfig<any> | undefined\n) {\n  // if we aren't inheriting anything or there are no params, return the input\n  if (!inheritedParams || !paramKeys.length) return baseParamConfigMap;\n\n  let paramConfigMap = { ...baseParamConfigMap };\n  let hasInherit = false;\n  for (const paramKey of paramKeys) {\n    // if it is missing a parameter, fill it in\n    if (!Object.prototype.hasOwnProperty.call(paramConfigMap, paramKey)) {\n      paramConfigMap[paramKey] = inheritedParams[paramKey] ?? defaultParam;\n      hasInherit = true;\n    }\n  }\n\n  if (!hasInherit) return baseParamConfigMap;\n  return paramConfigMap;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}