{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AnyTypeAnnotation = AnyTypeAnnotation;\nexports.ArrayTypeAnnotation = ArrayTypeAnnotation;\nexports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;\nexports.BooleanTypeAnnotation = BooleanTypeAnnotation;\nexports.DeclareClass = DeclareClass;\nexports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;\nexports.DeclareExportDeclaration = DeclareExportDeclaration;\nexports.DeclareFunction = DeclareFunction;\nexports.DeclareInterface = DeclareInterface;\nexports.DeclareModule = DeclareModule;\nexports.DeclareModuleExports = DeclareModuleExports;\nexports.DeclareOpaqueType = DeclareOpaqueType;\nexports.DeclareTypeAlias = DeclareTypeAlias;\nexports.DeclareVariable = DeclareVariable;\nexports.DeclaredPredicate = DeclaredPredicate;\nexports.EmptyTypeAnnotation = EmptyTypeAnnotation;\nexports.EnumBooleanBody = EnumBooleanBody;\nexports.EnumBooleanMember = EnumBooleanMember;\nexports.EnumDeclaration = EnumDeclaration;\nexports.EnumDefaultedMember = EnumDefaultedMember;\nexports.EnumNumberBody = EnumNumberBody;\nexports.EnumNumberMember = EnumNumberMember;\nexports.EnumStringBody = EnumStringBody;\nexports.EnumStringMember = EnumStringMember;\nexports.EnumSymbolBody = EnumSymbolBody;\nexports.ExistsTypeAnnotation = ExistsTypeAnnotation;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.FunctionTypeParam = FunctionTypeParam;\nexports.IndexedAccessType = IndexedAccessType;\nexports.InferredPredicate = InferredPredicate;\nexports.InterfaceDeclaration = InterfaceDeclaration;\nexports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;\nexports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;\nexports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;\nexports.MixedTypeAnnotation = MixedTypeAnnotation;\nexports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nObject.defineProperty(exports, \"NumberLiteralTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _types2.NumericLiteral;\n  }\n});\nexports.NumberTypeAnnotation = NumberTypeAnnotation;\nexports.ObjectTypeAnnotation = ObjectTypeAnnotation;\nexports.ObjectTypeCallProperty = ObjectTypeCallProperty;\nexports.ObjectTypeIndexer = ObjectTypeIndexer;\nexports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;\nexports.ObjectTypeProperty = ObjectTypeProperty;\nexports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;\nexports.OpaqueType = OpaqueType;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;\nObject.defineProperty(exports, \"StringLiteralTypeAnnotation\", {\n  enumerable: true,\n  get: function () {\n    return _types2.StringLiteral;\n  }\n});\nexports.StringTypeAnnotation = StringTypeAnnotation;\nexports.SymbolTypeAnnotation = SymbolTypeAnnotation;\nexports.ThisTypeAnnotation = ThisTypeAnnotation;\nexports.TupleTypeAnnotation = TupleTypeAnnotation;\nexports.TypeAlias = TypeAlias;\nexports.TypeAnnotation = TypeAnnotation;\nexports.TypeCastExpression = TypeCastExpression;\nexports.TypeParameter = TypeParameter;\nexports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;\nexports.TypeofTypeAnnotation = TypeofTypeAnnotation;\nexports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.Variance = Variance;\nexports.VoidTypeAnnotation = VoidTypeAnnotation;\nexports._interfaceish = _interfaceish;\nexports._variance = _variance;\nvar _t = require(\"@babel/types\");\nvar _modules = require(\"./modules\");\nvar _types2 = require(\"./types\");\nconst {\n  isDeclareExportDeclaration,\n  isStatement\n} = _t;\nfunction AnyTypeAnnotation() {\n  this.word(\"any\");\n}\nfunction ArrayTypeAnnotation(node) {\n  this.print(node.elementType, node, true);\n  this.tokenChar(91);\n  this.tokenChar(93);\n}\nfunction BooleanTypeAnnotation() {\n  this.word(\"boolean\");\n}\nfunction BooleanLiteralTypeAnnotation(node) {\n  this.word(node.value ? \"true\" : \"false\");\n}\nfunction NullLiteralTypeAnnotation() {\n  this.word(\"null\");\n}\nfunction DeclareClass(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"class\");\n  this.space();\n  this._interfaceish(node);\n}\nfunction DeclareFunction(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"function\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.id.typeAnnotation.typeAnnotation, node);\n  if (node.predicate) {\n    this.space();\n    this.print(node.predicate, node);\n  }\n  this.semicolon();\n}\nfunction InferredPredicate() {\n  this.tokenChar(37);\n  this.word(\"checks\");\n}\nfunction DeclaredPredicate(node) {\n  this.tokenChar(37);\n  this.word(\"checks\");\n  this.tokenChar(40);\n  this.print(node.value, node);\n  this.tokenChar(41);\n}\nfunction DeclareInterface(node) {\n  this.word(\"declare\");\n  this.space();\n  this.InterfaceDeclaration(node);\n}\nfunction DeclareModule(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.space();\n  this.print(node.id, node);\n  this.space();\n  this.print(node.body, node);\n}\nfunction DeclareModuleExports(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.tokenChar(46);\n  this.word(\"exports\");\n  this.print(node.typeAnnotation, node);\n}\nfunction DeclareTypeAlias(node) {\n  this.word(\"declare\");\n  this.space();\n  this.TypeAlias(node);\n}\nfunction DeclareOpaqueType(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.OpaqueType(node);\n}\nfunction DeclareVariable(node, parent) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"var\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.id.typeAnnotation, node);\n  this.semicolon();\n}\nfunction DeclareExportDeclaration(node) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"export\");\n  this.space();\n  if (node.default) {\n    this.word(\"default\");\n    this.space();\n  }\n  FlowExportDeclaration.call(this, node);\n}\nfunction DeclareExportAllDeclaration(node) {\n  this.word(\"declare\");\n  this.space();\n  _modules.ExportAllDeclaration.call(this, node);\n}\nfunction EnumDeclaration(node) {\n  const {\n    id,\n    body\n  } = node;\n  this.word(\"enum\");\n  this.space();\n  this.print(id, node);\n  this.print(body, node);\n}\nfunction enumExplicitType(context, name, hasExplicitType) {\n  if (hasExplicitType) {\n    context.space();\n    context.word(\"of\");\n    context.space();\n    context.word(name);\n  }\n  context.space();\n}\nfunction enumBody(context, node) {\n  const {\n    members\n  } = node;\n  context.token(\"{\");\n  context.indent();\n  context.newline();\n  for (const member of members) {\n    context.print(member, node);\n    context.newline();\n  }\n  if (node.hasUnknownMembers) {\n    context.token(\"...\");\n    context.newline();\n  }\n  context.dedent();\n  context.token(\"}\");\n}\nfunction EnumBooleanBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, \"boolean\", explicitType);\n  enumBody(this, node);\n}\nfunction EnumNumberBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, \"number\", explicitType);\n  enumBody(this, node);\n}\nfunction EnumStringBody(node) {\n  const {\n    explicitType\n  } = node;\n  enumExplicitType(this, \"string\", explicitType);\n  enumBody(this, node);\n}\nfunction EnumSymbolBody(node) {\n  enumExplicitType(this, \"symbol\", true);\n  enumBody(this, node);\n}\nfunction EnumDefaultedMember(node) {\n  const {\n    id\n  } = node;\n  this.print(id, node);\n  this.tokenChar(44);\n}\nfunction enumInitializedMember(context, node) {\n  const {\n    id,\n    init\n  } = node;\n  context.print(id, node);\n  context.space();\n  context.token(\"=\");\n  context.space();\n  context.print(init, node);\n  context.token(\",\");\n}\nfunction EnumBooleanMember(node) {\n  enumInitializedMember(this, node);\n}\nfunction EnumNumberMember(node) {\n  enumInitializedMember(this, node);\n}\nfunction EnumStringMember(node) {\n  enumInitializedMember(this, node);\n}\nfunction FlowExportDeclaration(node) {\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar, node);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    this.tokenChar(123);\n    if (node.specifiers.length) {\n      this.space();\n      this.printList(node.specifiers, node);\n      this.space();\n    }\n    this.tokenChar(125);\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      this.print(node.source, node);\n    }\n    this.semicolon();\n  }\n}\nfunction ExistsTypeAnnotation() {\n  this.tokenChar(42);\n}\nfunction FunctionTypeAnnotation(node, parent) {\n  this.print(node.typeParameters, node);\n  this.tokenChar(40);\n  if (node.this) {\n    this.word(\"this\");\n    this.tokenChar(58);\n    this.space();\n    this.print(node.this.typeAnnotation, node);\n    if (node.params.length || node.rest) {\n      this.tokenChar(44);\n      this.space();\n    }\n  }\n  this.printList(node.params, node);\n  if (node.rest) {\n    if (node.params.length) {\n      this.tokenChar(44);\n      this.space();\n    }\n    this.token(\"...\");\n    this.print(node.rest, node);\n  }\n  this.tokenChar(41);\n  if (parent && (parent.type === \"ObjectTypeCallProperty\" || parent.type === \"ObjectTypeInternalSlot\" || parent.type === \"DeclareFunction\" || parent.type === \"ObjectTypeProperty\" && parent.method)) {\n    this.tokenChar(58);\n  } else {\n    this.space();\n    this.token(\"=>\");\n  }\n  this.space();\n  this.print(node.returnType, node);\n}\nfunction FunctionTypeParam(node) {\n  this.print(node.name, node);\n  if (node.optional) this.tokenChar(63);\n  if (node.name) {\n    this.tokenChar(58);\n    this.space();\n  }\n  this.print(node.typeAnnotation, node);\n}\nfunction InterfaceExtends(node) {\n  this.print(node.id, node);\n  this.print(node.typeParameters, node, true);\n}\nfunction _interfaceish(node) {\n  var _node$extends;\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  if ((_node$extends = node.extends) != null && _node$extends.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends, node);\n  }\n  if (node.mixins && node.mixins.length) {\n    this.space();\n    this.word(\"mixins\");\n    this.space();\n    this.printList(node.mixins, node);\n  }\n  if (node.implements && node.implements.length) {\n    this.space();\n    this.word(\"implements\");\n    this.space();\n    this.printList(node.implements, node);\n  }\n  this.space();\n  this.print(node.body, node);\n}\nfunction _variance(node) {\n  if (node.variance) {\n    if (node.variance.kind === \"plus\") {\n      this.tokenChar(43);\n    } else if (node.variance.kind === \"minus\") {\n      this.tokenChar(45);\n    }\n  }\n}\nfunction InterfaceDeclaration(node) {\n  this.word(\"interface\");\n  this.space();\n  this._interfaceish(node);\n}\nfunction andSeparator() {\n  this.space();\n  this.tokenChar(38);\n  this.space();\n}\nfunction InterfaceTypeAnnotation(node) {\n  this.word(\"interface\");\n  if (node.extends && node.extends.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends, node);\n  }\n  this.space();\n  this.print(node.body, node);\n}\nfunction IntersectionTypeAnnotation(node) {\n  this.printJoin(node.types, node, {\n    separator: andSeparator\n  });\n}\nfunction MixedTypeAnnotation() {\n  this.word(\"mixed\");\n}\nfunction EmptyTypeAnnotation() {\n  this.word(\"empty\");\n}\nfunction NullableTypeAnnotation(node) {\n  this.tokenChar(63);\n  this.print(node.typeAnnotation, node);\n}\nfunction NumberTypeAnnotation() {\n  this.word(\"number\");\n}\nfunction StringTypeAnnotation() {\n  this.word(\"string\");\n}\nfunction ThisTypeAnnotation() {\n  this.word(\"this\");\n}\nfunction TupleTypeAnnotation(node) {\n  this.tokenChar(91);\n  this.printList(node.types, node);\n  this.tokenChar(93);\n}\nfunction TypeofTypeAnnotation(node) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.argument, node);\n}\nfunction TypeAlias(node) {\n  this.word(\"type\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(node.right, node);\n  this.semicolon();\n}\nfunction TypeAnnotation(node) {\n  this.tokenChar(58);\n  this.space();\n  if (node.optional) this.tokenChar(63);\n  this.print(node.typeAnnotation, node);\n}\nfunction TypeParameterInstantiation(node) {\n  this.tokenChar(60);\n  this.printList(node.params, node, {});\n  this.tokenChar(62);\n}\nfunction TypeParameter(node) {\n  this._variance(node);\n  this.word(node.name);\n  if (node.bound) {\n    this.print(node.bound, node);\n  }\n  if (node.default) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.default, node);\n  }\n}\nfunction OpaqueType(node) {\n  this.word(\"opaque\");\n  this.space();\n  this.word(\"type\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  if (node.supertype) {\n    this.tokenChar(58);\n    this.space();\n    this.print(node.supertype, node);\n  }\n  if (node.impltype) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.impltype, node);\n  }\n  this.semicolon();\n}\nfunction ObjectTypeAnnotation(node) {\n  if (node.exact) {\n    this.token(\"{|\");\n  } else {\n    this.tokenChar(123);\n  }\n  const props = [...node.properties, ...(node.callProperties || []), ...(node.indexers || []), ...(node.internalSlots || [])];\n  if (props.length) {\n    this.newline();\n    this.space();\n    this.printJoin(props, node, {\n      addNewlines(leading) {\n        if (leading && !props[0]) return 1;\n      },\n      indent: true,\n      statement: true,\n      iterator: () => {\n        if (props.length !== 1 || node.inexact) {\n          this.tokenChar(44);\n          this.space();\n        }\n      }\n    });\n    this.space();\n  }\n  if (node.inexact) {\n    this.indent();\n    this.token(\"...\");\n    if (props.length) {\n      this.newline();\n    }\n    this.dedent();\n  }\n  if (node.exact) {\n    this.token(\"|}\");\n  } else {\n    this.tokenChar(125);\n  }\n}\nfunction ObjectTypeInternalSlot(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.tokenChar(91);\n  this.tokenChar(91);\n  this.print(node.id, node);\n  this.tokenChar(93);\n  this.tokenChar(93);\n  if (node.optional) this.tokenChar(63);\n  if (!node.method) {\n    this.tokenChar(58);\n    this.space();\n  }\n  this.print(node.value, node);\n}\nfunction ObjectTypeCallProperty(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.print(node.value, node);\n}\nfunction ObjectTypeIndexer(node) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this._variance(node);\n  this.tokenChar(91);\n  if (node.id) {\n    this.print(node.id, node);\n    this.tokenChar(58);\n    this.space();\n  }\n  this.print(node.key, node);\n  this.tokenChar(93);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.value, node);\n}\nfunction ObjectTypeProperty(node) {\n  if (node.proto) {\n    this.word(\"proto\");\n    this.space();\n  }\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (node.kind === \"get\" || node.kind === \"set\") {\n    this.word(node.kind);\n    this.space();\n  }\n  this._variance(node);\n  this.print(node.key, node);\n  if (node.optional) this.tokenChar(63);\n  if (!node.method) {\n    this.tokenChar(58);\n    this.space();\n  }\n  this.print(node.value, node);\n}\nfunction ObjectTypeSpreadProperty(node) {\n  this.token(\"...\");\n  this.print(node.argument, node);\n}\nfunction QualifiedTypeIdentifier(node) {\n  this.print(node.qualification, node);\n  this.tokenChar(46);\n  this.print(node.id, node);\n}\nfunction SymbolTypeAnnotation() {\n  this.word(\"symbol\");\n}\nfunction orSeparator() {\n  this.space();\n  this.tokenChar(124);\n  this.space();\n}\nfunction UnionTypeAnnotation(node) {\n  this.printJoin(node.types, node, {\n    separator: orSeparator\n  });\n}\nfunction TypeCastExpression(node) {\n  this.tokenChar(40);\n  this.print(node.expression, node);\n  this.print(node.typeAnnotation, node);\n  this.tokenChar(41);\n}\nfunction Variance(node) {\n  if (node.kind === \"plus\") {\n    this.tokenChar(43);\n  } else {\n    this.tokenChar(45);\n  }\n}\nfunction VoidTypeAnnotation() {\n  this.word(\"void\");\n}\nfunction IndexedAccessType(node) {\n  this.print(node.objectType, node, true);\n  this.tokenChar(91);\n  this.print(node.indexType, node);\n  this.tokenChar(93);\n}\nfunction OptionalIndexedAccessType(node) {\n  this.print(node.objectType, node);\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n  this.tokenChar(91);\n  this.print(node.indexType, node);\n  this.tokenChar(93);\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AAEA;AAidA;AAGiB;EAtdRA,0BAA0B;EAAEC;AAAW;AAIzC,SAASC,iBAAiB,GAAgB;EAC/C,IAAI,CAACC,IAAI,CAAC,KAAK,CAAC;AAClB;AAEO,SAASC,mBAAmB,CAEjCC,IAA2B,EAC3B;EACA,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,WAAW,EAAEF,IAAI,EAAE,IAAI,CAAC;EACxC,IAAI,CAACG,SAAK,IAAK;EACf,IAAI,CAACA,SAAK,IAAK;AACjB;AAEO,SAASC,qBAAqB,GAAgB;EACnD,IAAI,CAACN,IAAI,CAAC,SAAS,CAAC;AACtB;AAEO,SAASO,4BAA4B,CAE1CL,IAAoC,EACpC;EACA,IAAI,CAACF,IAAI,CAACE,IAAI,CAACM,KAAK,GAAG,MAAM,GAAG,OAAO,CAAC;AAC1C;AAEO,SAASC,yBAAyB,GAAgB;EACvD,IAAI,CAACT,IAAI,CAAC,MAAM,CAAC;AACnB;AAEO,SAASU,YAAY,CAE1BR,IAAoB,EACpBS,MAAc,EACd;EACA,IAAI,CAACd,0BAA0B,CAACc,MAAM,CAAC,EAAE;IACvC,IAAI,CAACX,IAAI,CAAC,SAAS,CAAC;IACpB,IAAI,CAACY,KAAK,EAAE;EACd;EACA,IAAI,CAACZ,IAAI,CAAC,OAAO,CAAC;EAClB,IAAI,CAACY,KAAK,EAAE;EACZ,IAAI,CAACC,aAAa,CAACX,IAAI,CAAC;AAC1B;AAEO,SAASY,eAAe,CAE7BZ,IAAuB,EACvBS,MAAc,EACd;EACA,IAAI,CAACd,0BAA0B,CAACc,MAAM,CAAC,EAAE;IACvC,IAAI,CAACX,IAAI,CAAC,SAAS,CAAC;IACpB,IAAI,CAACY,KAAK,EAAE;EACd;EACA,IAAI,CAACZ,IAAI,CAAC,UAAU,CAAC;EACrB,IAAI,CAACY,KAAK,EAAE;EACZ,IAAI,CAACT,KAAK,CAACD,IAAI,CAACa,EAAE,EAAEb,IAAI,CAAC;EAEzB,IAAI,CAACC,KAAK,CAACD,IAAI,CAACa,EAAE,CAACC,cAAc,CAACA,cAAc,EAAEd,IAAI,CAAC;EAEvD,IAAIA,IAAI,CAACe,SAAS,EAAE;IAClB,IAAI,CAACL,KAAK,EAAE;IACZ,IAAI,CAACT,KAAK,CAACD,IAAI,CAACe,SAAS,EAAEf,IAAI,CAAC;EAClC;EAEA,IAAI,CAACgB,SAAS,EAAE;AAClB;AAEO,SAASC,iBAAiB,GAAgB;EAC/C,IAAI,CAACd,SAAK,IAAK;EACf,IAAI,CAACL,IAAI,CAAC,QAAQ,CAAC;AACrB;AAEO,SAASoB,iBAAiB,CAAgBlB,IAAyB,EAAE;EAC1E,IAAI,CAACG,SAAK,IAAK;EACf,IAAI,CAACL,IAAI,CAAC,QAAQ,CAAC;EACnB,IAAI,CAACK,SAAK,IAAK;EACf,IAAI,CAACF,KAAK,CAACD,IAAI,CAACM,KAAK,EAAEN,IAAI,CAAC;EAC5B,IAAI,CAACG,SAAK,IAAK;AACjB;AAEO,SAASgB,gBAAgB,CAAgBnB,IAAwB,EAAE;EACxE,IAAI,CAACF,IAAI,CAAC,SAAS,CAAC;EACpB,IAAI,CAACY,KAAK,EAAE;EACZ,IAAI,CAACU,oBAAoB,CAACpB,IAAI,CAAC;AACjC;AAEO,SAASqB,aAAa,CAAgBrB,IAAqB,EAAE;EAClE,IAAI,CAACF,IAAI,CAAC,SAAS,CAAC;EACpB,IAAI,CAACY,KAAK,EAAE;EACZ,IAAI,CAACZ,IAAI,CAAC,QAAQ,CAAC;EACnB,IAAI,CAACY,KAAK,EAAE;EACZ,IAAI,CAACT,KAAK,CAACD,IAAI,CAACa,EAAE,EAAEb,IAAI,CAAC;EACzB,IAAI,CAACU,KAAK,EAAE;EACZ,IAAI,CAACT,KAAK,CAACD,IAAI,CAACsB,IAAI,EAAEtB,IAAI,CAAC;AAC7B;AAEO,SAASuB,oBAAoB,CAElCvB,IAA4B,EAC5B;EACA,IAAI,CAACF,IAAI,CAAC,SAAS,CAAC;EACpB,IAAI,CAACY,KAAK,EAAE;EACZ,IAAI,CAACZ,IAAI,CAAC,QAAQ,CAAC;EACnB,IAAI,CAACK,SAAK,IAAK;EACf,IAAI,CAACL,IAAI,CAAC,SAAS,CAAC;EACpB,IAAI,CAACG,KAAK,CAACD,IAAI,CAACc,cAAc,EAAEd,IAAI,CAAC;AACvC;AAEO,SAASwB,gBAAgB,CAAgBxB,IAAwB,EAAE;EACxE,IAAI,CAACF,IAAI,CAAC,SAAS,CAAC;EACpB,IAAI,CAACY,KAAK,EAAE;EACZ,IAAI,CAACe,SAAS,CAACzB,IAAI,CAAC;AACtB;AAEO,SAAS0B,iBAAiB,CAE/B1B,IAAyB,EACzBS,MAAc,EACd;EACA,IAAI,CAACd,0BAA0B,CAACc,MAAM,CAAC,EAAE;IACvC,IAAI,CAACX,IAAI,CAAC,SAAS,CAAC;IACpB,IAAI,CAACY,KAAK,EAAE;EACd;EACA,IAAI,CAACiB,UAAU,CAAC3B,IAAI,CAAC;AACvB;AAEO,SAAS4B,eAAe,CAE7B5B,IAAuB,EACvBS,MAAc,EACd;EACA,IAAI,CAACd,0BAA0B,CAACc,MAAM,CAAC,EAAE;IACvC,IAAI,CAACX,IAAI,CAAC,SAAS,CAAC;IACpB,IAAI,CAACY,KAAK,EAAE;EACd;EACA,IAAI,CAACZ,IAAI,CAAC,KAAK,CAAC;EAChB,IAAI,CAACY,KAAK,EAAE;EACZ,IAAI,CAACT,KAAK,CAACD,IAAI,CAACa,EAAE,EAAEb,IAAI,CAAC;EACzB,IAAI,CAACC,KAAK,CAACD,IAAI,CAACa,EAAE,CAACC,cAAc,EAAEd,IAAI,CAAC;EACxC,IAAI,CAACgB,SAAS,EAAE;AAClB;AAEO,SAASa,wBAAwB,CAEtC7B,IAAgC,EAChC;EACA,IAAI,CAACF,IAAI,CAAC,SAAS,CAAC;EACpB,IAAI,CAACY,KAAK,EAAE;EACZ,IAAI,CAACZ,IAAI,CAAC,QAAQ,CAAC;EACnB,IAAI,CAACY,KAAK,EAAE;EACZ,IAAIV,IAAI,CAAC8B,OAAO,EAAE;IAChB,IAAI,CAAChC,IAAI,CAAC,SAAS,CAAC;IACpB,IAAI,CAACY,KAAK,EAAE;EACd;EAEAqB,qBAAqB,CAACC,IAAI,CAAC,IAAI,EAAEhC,IAAI,CAAC;AACxC;AAEO,SAASiC,2BAA2B,CAEzCjC,IAAmC,EACnC;EACA,IAAI,CAACF,IAAI,CAAC,SAAS,CAAC;EACpB,IAAI,CAACY,KAAK,EAAE;EACZwB,6BAAoB,CAACF,IAAI,CAAC,IAAI,EAAEhC,IAAI,CAAC;AACvC;AAEO,SAASmC,eAAe,CAAgBnC,IAAuB,EAAE;EACtE,MAAM;IAAEa,EAAE;IAAES;EAAK,CAAC,GAAGtB,IAAI;EACzB,IAAI,CAACF,IAAI,CAAC,MAAM,CAAC;EACjB,IAAI,CAACY,KAAK,EAAE;EACZ,IAAI,CAACT,KAAK,CAACY,EAAE,EAAEb,IAAI,CAAC;EACpB,IAAI,CAACC,KAAK,CAACqB,IAAI,EAAEtB,IAAI,CAAC;AACxB;AAEA,SAASoC,gBAAgB,CACvBC,OAAgB,EAChBC,IAAY,EACZC,eAAwB,EACxB;EACA,IAAIA,eAAe,EAAE;IACnBF,OAAO,CAAC3B,KAAK,EAAE;IACf2B,OAAO,CAACvC,IAAI,CAAC,IAAI,CAAC;IAClBuC,OAAO,CAAC3B,KAAK,EAAE;IACf2B,OAAO,CAACvC,IAAI,CAACwC,IAAI,CAAC;EACpB;EACAD,OAAO,CAAC3B,KAAK,EAAE;AACjB;AAEA,SAAS8B,QAAQ,CAACH,OAAgB,EAAErC,IAAgB,EAAE;EACpD,MAAM;IAAEyC;EAAQ,CAAC,GAAGzC,IAAI;EACxBqC,OAAO,CAAClC,KAAK,CAAC,GAAG,CAAC;EAClBkC,OAAO,CAACK,MAAM,EAAE;EAChBL,OAAO,CAACM,OAAO,EAAE;EACjB,KAAK,MAAMC,MAAM,IAAIH,OAAO,EAAE;IAC5BJ,OAAO,CAACpC,KAAK,CAAC2C,MAAM,EAAE5C,IAAI,CAAC;IAC3BqC,OAAO,CAACM,OAAO,EAAE;EACnB;EACA,IAAI3C,IAAI,CAAC6C,iBAAiB,EAAE;IAC1BR,OAAO,CAAClC,KAAK,CAAC,KAAK,CAAC;IACpBkC,OAAO,CAACM,OAAO,EAAE;EACnB;EACAN,OAAO,CAACS,MAAM,EAAE;EAChBT,OAAO,CAAClC,KAAK,CAAC,GAAG,CAAC;AACpB;AAEO,SAAS4C,eAAe,CAAgB/C,IAAuB,EAAE;EACtE,MAAM;IAAEgD;EAAa,CAAC,GAAGhD,IAAI;EAC7BoC,gBAAgB,CAAC,IAAI,EAAE,SAAS,EAAEY,YAAY,CAAC;EAC/CR,QAAQ,CAAC,IAAI,EAAExC,IAAI,CAAC;AACtB;AAEO,SAASiD,cAAc,CAAgBjD,IAAsB,EAAE;EACpE,MAAM;IAAEgD;EAAa,CAAC,GAAGhD,IAAI;EAC7BoC,gBAAgB,CAAC,IAAI,EAAE,QAAQ,EAAEY,YAAY,CAAC;EAC9CR,QAAQ,CAAC,IAAI,EAAExC,IAAI,CAAC;AACtB;AAEO,SAASkD,cAAc,CAAgBlD,IAAsB,EAAE;EACpE,MAAM;IAAEgD;EAAa,CAAC,GAAGhD,IAAI;EAC7BoC,gBAAgB,CAAC,IAAI,EAAE,QAAQ,EAAEY,YAAY,CAAC;EAC9CR,QAAQ,CAAC,IAAI,EAAExC,IAAI,CAAC;AACtB;AAEO,SAASmD,cAAc,CAAgBnD,IAAsB,EAAE;EACpEoC,gBAAgB,CAAC,IAAI,EAAE,QAAQ,EAAE,IAAI,CAAC;EACtCI,QAAQ,CAAC,IAAI,EAAExC,IAAI,CAAC;AACtB;AAEO,SAASoD,mBAAmB,CAEjCpD,IAA2B,EAC3B;EACA,MAAM;IAAEa;EAAG,CAAC,GAAGb,IAAI;EACnB,IAAI,CAACC,KAAK,CAACY,EAAE,EAAEb,IAAI,CAAC;EACpB,IAAI,CAACG,SAAK,IAAK;AACjB;AAEA,SAASkD,qBAAqB,CAC5BhB,OAAgB,EAChBrC,IAAmE,EACnE;EACA,MAAM;IAAEa,EAAE;IAAEyC;EAAK,CAAC,GAAGtD,IAAI;EACzBqC,OAAO,CAACpC,KAAK,CAACY,EAAE,EAAEb,IAAI,CAAC;EACvBqC,OAAO,CAAC3B,KAAK,EAAE;EACf2B,OAAO,CAAClC,KAAK,CAAC,GAAG,CAAC;EAClBkC,OAAO,CAAC3B,KAAK,EAAE;EACf2B,OAAO,CAACpC,KAAK,CAACqD,IAAI,EAAEtD,IAAI,CAAC;EACzBqC,OAAO,CAAClC,KAAK,CAAC,GAAG,CAAC;AACpB;AAEO,SAASoD,iBAAiB,CAAgBvD,IAAyB,EAAE;EAC1EqD,qBAAqB,CAAC,IAAI,EAAErD,IAAI,CAAC;AACnC;AAEO,SAASwD,gBAAgB,CAAgBxD,IAAwB,EAAE;EACxEqD,qBAAqB,CAAC,IAAI,EAAErD,IAAI,CAAC;AACnC;AAEO,SAASyD,gBAAgB,CAAgBzD,IAAwB,EAAE;EACxEqD,qBAAqB,CAAC,IAAI,EAAErD,IAAI,CAAC;AACnC;AAEA,SAAS+B,qBAAqB,CAE5B/B,IAAgC,EAChC;EACA,IAAIA,IAAI,CAAC0D,WAAW,EAAE;IACpB,MAAMC,MAAM,GAAG3D,IAAI,CAAC0D,WAAW;IAC/B,IAAI,CAACzD,KAAK,CAAC0D,MAAM,EAAE3D,IAAI,CAAC;IACxB,IAAI,CAACJ,WAAW,CAAC+D,MAAM,CAAC,EAAE,IAAI,CAAC3C,SAAS,EAAE;EAC5C,CAAC,MAAM;IACL,IAAI,CAACb,SAAK,KAAK;IACf,IAAIH,IAAI,CAAC4D,UAAU,CAACC,MAAM,EAAE;MAC1B,IAAI,CAACnD,KAAK,EAAE;MACZ,IAAI,CAACoD,SAAS,CAAC9D,IAAI,CAAC4D,UAAU,EAAE5D,IAAI,CAAC;MACrC,IAAI,CAACU,KAAK,EAAE;IACd;IACA,IAAI,CAACP,SAAK,KAAK;IAEf,IAAIH,IAAI,CAAC+D,MAAM,EAAE;MACf,IAAI,CAACrD,KAAK,EAAE;MACZ,IAAI,CAACZ,IAAI,CAAC,MAAM,CAAC;MACjB,IAAI,CAACY,KAAK,EAAE;MACZ,IAAI,CAACT,KAAK,CAACD,IAAI,CAAC+D,MAAM,EAAE/D,IAAI,CAAC;IAC/B;IAEA,IAAI,CAACgB,SAAS,EAAE;EAClB;AACF;AAEO,SAASgD,oBAAoB,GAAgB;EAClD,IAAI,CAAC7D,SAAK,IAAK;AACjB;AAEO,SAAS8D,sBAAsB,CAEpCjE,IAA8B,EAC9BS,MAAqB,EACrB;EACA,IAAI,CAACR,KAAK,CAACD,IAAI,CAACkE,cAAc,EAAElE,IAAI,CAAC;EACrC,IAAI,CAACG,SAAK,IAAK;EAEf,IAAIH,IAAI,CAACmE,IAAI,EAAE;IACb,IAAI,CAACrE,IAAI,CAAC,MAAM,CAAC;IACjB,IAAI,CAACK,SAAK,IAAK;IACf,IAAI,CAACO,KAAK,EAAE;IACZ,IAAI,CAACT,KAAK,CAACD,IAAI,CAACmE,IAAI,CAACrD,cAAc,EAAEd,IAAI,CAAC;IAC1C,IAAIA,IAAI,CAACoE,MAAM,CAACP,MAAM,IAAI7D,IAAI,CAACqE,IAAI,EAAE;MACnC,IAAI,CAAClE,SAAK,IAAK;MACf,IAAI,CAACO,KAAK,EAAE;IACd;EACF;EAEA,IAAI,CAACoD,SAAS,CAAC9D,IAAI,CAACoE,MAAM,EAAEpE,IAAI,CAAC;EAEjC,IAAIA,IAAI,CAACqE,IAAI,EAAE;IACb,IAAIrE,IAAI,CAACoE,MAAM,CAACP,MAAM,EAAE;MACtB,IAAI,CAAC1D,SAAK,IAAK;MACf,IAAI,CAACO,KAAK,EAAE;IACd;IACA,IAAI,CAACP,KAAK,CAAC,KAAK,CAAC;IACjB,IAAI,CAACF,KAAK,CAACD,IAAI,CAACqE,IAAI,EAAErE,IAAI,CAAC;EAC7B;EAEA,IAAI,CAACG,SAAK,IAAK;EAGf,IACEM,MAAM,KACLA,MAAM,CAAC6D,IAAI,KAAK,wBAAwB,IACvC7D,MAAM,CAAC6D,IAAI,KAAK,wBAAwB,IACxC7D,MAAM,CAAC6D,IAAI,KAAK,iBAAiB,IAChC7D,MAAM,CAAC6D,IAAI,KAAK,oBAAoB,IAAI7D,MAAM,CAAC8D,MAAO,CAAC,EAC1D;IACA,IAAI,CAACpE,SAAK,IAAK;EACjB,CAAC,MAAM;IACL,IAAI,CAACO,KAAK,EAAE;IACZ,IAAI,CAACP,KAAK,CAAC,IAAI,CAAC;EAClB;EAEA,IAAI,CAACO,KAAK,EAAE;EACZ,IAAI,CAACT,KAAK,CAACD,IAAI,CAACwE,UAAU,EAAExE,IAAI,CAAC;AACnC;AAEO,SAASyE,iBAAiB,CAAgBzE,IAAyB,EAAE;EAC1E,IAAI,CAACC,KAAK,CAACD,IAAI,CAACsC,IAAI,EAAEtC,IAAI,CAAC;EAC3B,IAAIA,IAAI,CAAC0E,QAAQ,EAAE,IAAI,CAACvE,SAAK,IAAK;EAClC,IAAIH,IAAI,CAACsC,IAAI,EAAE;IACb,IAAI,CAACnC,SAAK,IAAK;IACf,IAAI,CAACO,KAAK,EAAE;EACd;EACA,IAAI,CAACT,KAAK,CAACD,IAAI,CAACc,cAAc,EAAEd,IAAI,CAAC;AACvC;AAEO,SAAS2E,gBAAgB,CAAgB3E,IAAwB,EAAE;EACxE,IAAI,CAACC,KAAK,CAACD,IAAI,CAACa,EAAE,EAAEb,IAAI,CAAC;EACzB,IAAI,CAACC,KAAK,CAACD,IAAI,CAACkE,cAAc,EAAElE,IAAI,EAAE,IAAI,CAAC;AAC7C;AAOO,SAASW,aAAa,CAE3BX,IAAkE,EAClE;EAAA;EACA,IAAI,CAACC,KAAK,CAACD,IAAI,CAACa,EAAE,EAAEb,IAAI,CAAC;EACzB,IAAI,CAACC,KAAK,CAACD,IAAI,CAACkE,cAAc,EAAElE,IAAI,CAAC;EACrC,qBAAIA,IAAI,CAAC4E,OAAO,aAAZC,cAAchB,MAAM,EAAE;IACxB,IAAI,CAACnD,KAAK,EAAE;IACZ,IAAI,CAACZ,IAAI,CAAC,SAAS,CAAC;IACpB,IAAI,CAACY,KAAK,EAAE;IACZ,IAAI,CAACoD,SAAS,CAAC9D,IAAI,CAAC4E,OAAO,EAAE5E,IAAI,CAAC;EACpC;EACA,IAAIA,IAAI,CAAC8E,MAAM,IAAI9E,IAAI,CAAC8E,MAAM,CAACjB,MAAM,EAAE;IACrC,IAAI,CAACnD,KAAK,EAAE;IACZ,IAAI,CAACZ,IAAI,CAAC,QAAQ,CAAC;IACnB,IAAI,CAACY,KAAK,EAAE;IACZ,IAAI,CAACoD,SAAS,CAAC9D,IAAI,CAAC8E,MAAM,EAAE9E,IAAI,CAAC;EACnC;EACA,IAAIA,IAAI,CAAC+E,UAAU,IAAI/E,IAAI,CAAC+E,UAAU,CAAClB,MAAM,EAAE;IAC7C,IAAI,CAACnD,KAAK,EAAE;IACZ,IAAI,CAACZ,IAAI,CAAC,YAAY,CAAC;IACvB,IAAI,CAACY,KAAK,EAAE;IACZ,IAAI,CAACoD,SAAS,CAAC9D,IAAI,CAAC+E,UAAU,EAAE/E,IAAI,CAAC;EACvC;EACA,IAAI,CAACU,KAAK,EAAE;EACZ,IAAI,CAACT,KAAK,CAACD,IAAI,CAACsB,IAAI,EAAEtB,IAAI,CAAC;AAC7B;AAEO,SAASgF,SAAS,CAEvBhF,IAM2B,EAC3B;EACA,IAAIA,IAAI,CAACiF,QAAQ,EAAE;IACjB,IAAIjF,IAAI,CAACiF,QAAQ,CAACC,IAAI,KAAK,MAAM,EAAE;MACjC,IAAI,CAAC/E,SAAK,IAAK;IACjB,CAAC,MAAM,IAAIH,IAAI,CAACiF,QAAQ,CAACC,IAAI,KAAK,OAAO,EAAE;MACzC,IAAI,CAAC/E,SAAK,IAAK;IACjB;EACF;AACF;AAEO,SAASiB,oBAAoB,CAElCpB,IAAiD,EACjD;EACA,IAAI,CAACF,IAAI,CAAC,WAAW,CAAC;EACtB,IAAI,CAACY,KAAK,EAAE;EACZ,IAAI,CAACC,aAAa,CAACX,IAAI,CAAC;AAC1B;AAEA,SAASmF,YAAY,GAAgB;EACnC,IAAI,CAACzE,KAAK,EAAE;EACZ,IAAI,CAACP,SAAK,IAAK;EACf,IAAI,CAACO,KAAK,EAAE;AACd;AAEO,SAAS0E,uBAAuB,CAErCpF,IAA+B,EAC/B;EACA,IAAI,CAACF,IAAI,CAAC,WAAW,CAAC;EACtB,IAAIE,IAAI,CAAC4E,OAAO,IAAI5E,IAAI,CAAC4E,OAAO,CAACf,MAAM,EAAE;IACvC,IAAI,CAACnD,KAAK,EAAE;IACZ,IAAI,CAACZ,IAAI,CAAC,SAAS,CAAC;IACpB,IAAI,CAACY,KAAK,EAAE;IACZ,IAAI,CAACoD,SAAS,CAAC9D,IAAI,CAAC4E,OAAO,EAAE5E,IAAI,CAAC;EACpC;EACA,IAAI,CAACU,KAAK,EAAE;EACZ,IAAI,CAACT,KAAK,CAACD,IAAI,CAACsB,IAAI,EAAEtB,IAAI,CAAC;AAC7B;AAEO,SAASqF,0BAA0B,CAExCrF,IAAkC,EAClC;EACA,IAAI,CAACsF,SAAS,CAACtF,IAAI,CAACuF,KAAK,EAAEvF,IAAI,EAAE;IAAEwF,SAAS,EAAEL;EAAa,CAAC,CAAC;AAC/D;AAEO,SAASM,mBAAmB,GAAgB;EACjD,IAAI,CAAC3F,IAAI,CAAC,OAAO,CAAC;AACpB;AAEO,SAAS4F,mBAAmB,GAAgB;EACjD,IAAI,CAAC5F,IAAI,CAAC,OAAO,CAAC;AACpB;AAEO,SAAS6F,sBAAsB,CAEpC3F,IAA8B,EAC9B;EACA,IAAI,CAACG,SAAK,IAAK;EACf,IAAI,CAACF,KAAK,CAACD,IAAI,CAACc,cAAc,EAAEd,IAAI,CAAC;AACvC;AAOO,SAAS4F,oBAAoB,GAAgB;EAClD,IAAI,CAAC9F,IAAI,CAAC,QAAQ,CAAC;AACrB;AAEO,SAAS+F,oBAAoB,GAAgB;EAClD,IAAI,CAAC/F,IAAI,CAAC,QAAQ,CAAC;AACrB;AAEO,SAASgG,kBAAkB,GAAgB;EAChD,IAAI,CAAChG,IAAI,CAAC,MAAM,CAAC;AACnB;AAEO,SAASiG,mBAAmB,CAEjC/F,IAA2B,EAC3B;EACA,IAAI,CAACG,SAAK,IAAK;EACf,IAAI,CAAC2D,SAAS,CAAC9D,IAAI,CAACuF,KAAK,EAAEvF,IAAI,CAAC;EAChC,IAAI,CAACG,SAAK,IAAK;AACjB;AAEO,SAAS6F,oBAAoB,CAElChG,IAA4B,EAC5B;EACA,IAAI,CAACF,IAAI,CAAC,QAAQ,CAAC;EACnB,IAAI,CAACY,KAAK,EAAE;EACZ,IAAI,CAACT,KAAK,CAACD,IAAI,CAACiG,QAAQ,EAAEjG,IAAI,CAAC;AACjC;AAEO,SAASyB,SAAS,CAEvBzB,IAAsC,EACtC;EACA,IAAI,CAACF,IAAI,CAAC,MAAM,CAAC;EACjB,IAAI,CAACY,KAAK,EAAE;EACZ,IAAI,CAACT,KAAK,CAACD,IAAI,CAACa,EAAE,EAAEb,IAAI,CAAC;EACzB,IAAI,CAACC,KAAK,CAACD,IAAI,CAACkE,cAAc,EAAElE,IAAI,CAAC;EACrC,IAAI,CAACU,KAAK,EAAE;EACZ,IAAI,CAACP,SAAK,IAAK;EACf,IAAI,CAACO,KAAK,EAAE;EACZ,IAAI,CAACT,KAAK,CAACD,IAAI,CAACkG,KAAK,EAAElG,IAAI,CAAC;EAC5B,IAAI,CAACgB,SAAS,EAAE;AAClB;AAEO,SAASmF,cAAc,CAAgBnG,IAAsB,EAAE;EACpE,IAAI,CAACG,SAAK,IAAK;EACf,IAAI,CAACO,KAAK,EAAE;EAEZ,IAAIV,IAAI,CAAC0E,QAAQ,EAAE,IAAI,CAACvE,SAAK,IAAK;EAClC,IAAI,CAACF,KAAK,CAACD,IAAI,CAACc,cAAc,EAAEd,IAAI,CAAC;AACvC;AAEO,SAASoG,0BAA0B,CAExCpG,IAAkC,EAC5B;EACN,IAAI,CAACG,SAAK,IAAK;EACf,IAAI,CAAC2D,SAAS,CAAC9D,IAAI,CAACoE,MAAM,EAAEpE,IAAI,EAAE,CAAC,CAAC,CAAC;EACrC,IAAI,CAACG,SAAK,IAAK;AACjB;AAIO,SAASkG,aAAa,CAAgBrG,IAAqB,EAAE;EAClE,IAAI,CAACgF,SAAS,CAAChF,IAAI,CAAC;EAEpB,IAAI,CAACF,IAAI,CAACE,IAAI,CAACsC,IAAI,CAAC;EAEpB,IAAItC,IAAI,CAACsG,KAAK,EAAE;IACd,IAAI,CAACrG,KAAK,CAACD,IAAI,CAACsG,KAAK,EAAEtG,IAAI,CAAC;EAC9B;EAEA,IAAIA,IAAI,CAAC8B,OAAO,EAAE;IAChB,IAAI,CAACpB,KAAK,EAAE;IACZ,IAAI,CAACP,SAAK,IAAK;IACf,IAAI,CAACO,KAAK,EAAE;IACZ,IAAI,CAACT,KAAK,CAACD,IAAI,CAAC8B,OAAO,EAAE9B,IAAI,CAAC;EAChC;AACF;AAEO,SAAS2B,UAAU,CAExB3B,IAAwC,EACxC;EACA,IAAI,CAACF,IAAI,CAAC,QAAQ,CAAC;EACnB,IAAI,CAACY,KAAK,EAAE;EACZ,IAAI,CAACZ,IAAI,CAAC,MAAM,CAAC;EACjB,IAAI,CAACY,KAAK,EAAE;EACZ,IAAI,CAACT,KAAK,CAACD,IAAI,CAACa,EAAE,EAAEb,IAAI,CAAC;EACzB,IAAI,CAACC,KAAK,CAACD,IAAI,CAACkE,cAAc,EAAElE,IAAI,CAAC;EACrC,IAAIA,IAAI,CAACuG,SAAS,EAAE;IAClB,IAAI,CAACpG,SAAK,IAAK;IACf,IAAI,CAACO,KAAK,EAAE;IACZ,IAAI,CAACT,KAAK,CAACD,IAAI,CAACuG,SAAS,EAAEvG,IAAI,CAAC;EAClC;EAEA,IAAIA,IAAI,CAACwG,QAAQ,EAAE;IACjB,IAAI,CAAC9F,KAAK,EAAE;IACZ,IAAI,CAACP,SAAK,IAAK;IACf,IAAI,CAACO,KAAK,EAAE;IACZ,IAAI,CAACT,KAAK,CAACD,IAAI,CAACwG,QAAQ,EAAExG,IAAI,CAAC;EACjC;EACA,IAAI,CAACgB,SAAS,EAAE;AAClB;AAEO,SAASyF,oBAAoB,CAElCzG,IAA4B,EAC5B;EACA,IAAIA,IAAI,CAAC0G,KAAK,EAAE;IACd,IAAI,CAACvG,KAAK,CAAC,IAAI,CAAC;EAClB,CAAC,MAAM;IACL,IAAI,CAACA,SAAK,KAAK;EACjB;EAGA,MAAMwG,KAAK,GAAG,CACZ,GAAG3G,IAAI,CAAC4G,UAAU,EAClB,IAAI5G,IAAI,CAAC6G,cAAc,IAAI,EAAE,CAAC,EAC9B,IAAI7G,IAAI,CAAC8G,QAAQ,IAAI,EAAE,CAAC,EACxB,IAAI9G,IAAI,CAAC+G,aAAa,IAAI,EAAE,CAAC,CAC9B;EAED,IAAIJ,KAAK,CAAC9C,MAAM,EAAE;IAChB,IAAI,CAAClB,OAAO,EAAE;IAEd,IAAI,CAACjC,KAAK,EAAE;IAEZ,IAAI,CAAC4E,SAAS,CAACqB,KAAK,EAAE3G,IAAI,EAAE;MAC1BgH,WAAW,CAACC,OAAO,EAAE;QACnB,IAAIA,OAAO,IAAI,CAACN,KAAK,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC;MACpC,CAAC;MACDjE,MAAM,EAAE,IAAI;MACZwE,SAAS,EAAE,IAAI;MACfC,QAAQ,EAAE,MAAM;QACd,IAAIR,KAAK,CAAC9C,MAAM,KAAK,CAAC,IAAI7D,IAAI,CAACoH,OAAO,EAAE;UACtC,IAAI,CAACjH,SAAK,IAAK;UACf,IAAI,CAACO,KAAK,EAAE;QACd;MACF;IACF,CAAC,CAAC;IAEF,IAAI,CAACA,KAAK,EAAE;EACd;EAEA,IAAIV,IAAI,CAACoH,OAAO,EAAE;IAChB,IAAI,CAAC1E,MAAM,EAAE;IACb,IAAI,CAACvC,KAAK,CAAC,KAAK,CAAC;IACjB,IAAIwG,KAAK,CAAC9C,MAAM,EAAE;MAChB,IAAI,CAAClB,OAAO,EAAE;IAChB;IACA,IAAI,CAACG,MAAM,EAAE;EACf;EAEA,IAAI9C,IAAI,CAAC0G,KAAK,EAAE;IACd,IAAI,CAACvG,KAAK,CAAC,IAAI,CAAC;EAClB,CAAC,MAAM;IACL,IAAI,CAACA,SAAK,KAAK;EACjB;AACF;AAEO,SAASkH,sBAAsB,CAEpCrH,IAA8B,EAC9B;EACA,IAAIA,IAAI,CAACsH,MAAM,EAAE;IACf,IAAI,CAACxH,IAAI,CAAC,QAAQ,CAAC;IACnB,IAAI,CAACY,KAAK,EAAE;EACd;EACA,IAAI,CAACP,SAAK,IAAK;EACf,IAAI,CAACA,SAAK,IAAK;EACf,IAAI,CAACF,KAAK,CAACD,IAAI,CAACa,EAAE,EAAEb,IAAI,CAAC;EACzB,IAAI,CAACG,SAAK,IAAK;EACf,IAAI,CAACA,SAAK,IAAK;EACf,IAAIH,IAAI,CAAC0E,QAAQ,EAAE,IAAI,CAACvE,SAAK,IAAK;EAClC,IAAI,CAACH,IAAI,CAACuE,MAAM,EAAE;IAChB,IAAI,CAACpE,SAAK,IAAK;IACf,IAAI,CAACO,KAAK,EAAE;EACd;EACA,IAAI,CAACT,KAAK,CAACD,IAAI,CAACM,KAAK,EAAEN,IAAI,CAAC;AAC9B;AAEO,SAASuH,sBAAsB,CAEpCvH,IAA8B,EAC9B;EACA,IAAIA,IAAI,CAACsH,MAAM,EAAE;IACf,IAAI,CAACxH,IAAI,CAAC,QAAQ,CAAC;IACnB,IAAI,CAACY,KAAK,EAAE;EACd;EACA,IAAI,CAACT,KAAK,CAACD,IAAI,CAACM,KAAK,EAAEN,IAAI,CAAC;AAC9B;AAEO,SAASwH,iBAAiB,CAAgBxH,IAAyB,EAAE;EAC1E,IAAIA,IAAI,CAACsH,MAAM,EAAE;IACf,IAAI,CAACxH,IAAI,CAAC,QAAQ,CAAC;IACnB,IAAI,CAACY,KAAK,EAAE;EACd;EACA,IAAI,CAACsE,SAAS,CAAChF,IAAI,CAAC;EACpB,IAAI,CAACG,SAAK,IAAK;EACf,IAAIH,IAAI,CAACa,EAAE,EAAE;IACX,IAAI,CAACZ,KAAK,CAACD,IAAI,CAACa,EAAE,EAAEb,IAAI,CAAC;IACzB,IAAI,CAACG,SAAK,IAAK;IACf,IAAI,CAACO,KAAK,EAAE;EACd;EACA,IAAI,CAACT,KAAK,CAACD,IAAI,CAACyH,GAAG,EAAEzH,IAAI,CAAC;EAC1B,IAAI,CAACG,SAAK,IAAK;EACf,IAAI,CAACA,SAAK,IAAK;EACf,IAAI,CAACO,KAAK,EAAE;EACZ,IAAI,CAACT,KAAK,CAACD,IAAI,CAACM,KAAK,EAAEN,IAAI,CAAC;AAC9B;AAEO,SAAS0H,kBAAkB,CAAgB1H,IAA0B,EAAE;EAC5E,IAAIA,IAAI,CAAC2H,KAAK,EAAE;IACd,IAAI,CAAC7H,IAAI,CAAC,OAAO,CAAC;IAClB,IAAI,CAACY,KAAK,EAAE;EACd;EACA,IAAIV,IAAI,CAACsH,MAAM,EAAE;IACf,IAAI,CAACxH,IAAI,CAAC,QAAQ,CAAC;IACnB,IAAI,CAACY,KAAK,EAAE;EACd;EACA,IAAIV,IAAI,CAACkF,IAAI,KAAK,KAAK,IAAIlF,IAAI,CAACkF,IAAI,KAAK,KAAK,EAAE;IAC9C,IAAI,CAACpF,IAAI,CAACE,IAAI,CAACkF,IAAI,CAAC;IACpB,IAAI,CAACxE,KAAK,EAAE;EACd;EACA,IAAI,CAACsE,SAAS,CAAChF,IAAI,CAAC;EACpB,IAAI,CAACC,KAAK,CAACD,IAAI,CAACyH,GAAG,EAAEzH,IAAI,CAAC;EAC1B,IAAIA,IAAI,CAAC0E,QAAQ,EAAE,IAAI,CAACvE,SAAK,IAAK;EAClC,IAAI,CAACH,IAAI,CAACuE,MAAM,EAAE;IAChB,IAAI,CAACpE,SAAK,IAAK;IACf,IAAI,CAACO,KAAK,EAAE;EACd;EACA,IAAI,CAACT,KAAK,CAACD,IAAI,CAACM,KAAK,EAAEN,IAAI,CAAC;AAC9B;AAEO,SAAS4H,wBAAwB,CAEtC5H,IAAgC,EAChC;EACA,IAAI,CAACG,KAAK,CAAC,KAAK,CAAC;EACjB,IAAI,CAACF,KAAK,CAACD,IAAI,CAACiG,QAAQ,EAAEjG,IAAI,CAAC;AACjC;AAEO,SAAS6H,uBAAuB,CAErC7H,IAA+B,EAC/B;EACA,IAAI,CAACC,KAAK,CAACD,IAAI,CAAC8H,aAAa,EAAE9H,IAAI,CAAC;EACpC,IAAI,CAACG,SAAK,IAAK;EACf,IAAI,CAACF,KAAK,CAACD,IAAI,CAACa,EAAE,EAAEb,IAAI,CAAC;AAC3B;AAEO,SAAS+H,oBAAoB,GAAgB;EAClD,IAAI,CAACjI,IAAI,CAAC,QAAQ,CAAC;AACrB;AAEA,SAASkI,WAAW,GAAgB;EAClC,IAAI,CAACtH,KAAK,EAAE;EACZ,IAAI,CAACP,SAAK,KAAK;EACf,IAAI,CAACO,KAAK,EAAE;AACd;AAEO,SAASuH,mBAAmB,CAEjCjI,IAA2B,EAC3B;EACA,IAAI,CAACsF,SAAS,CAACtF,IAAI,CAACuF,KAAK,EAAEvF,IAAI,EAAE;IAAEwF,SAAS,EAAEwC;EAAY,CAAC,CAAC;AAC9D;AAEO,SAASE,kBAAkB,CAAgBlI,IAA0B,EAAE;EAC5E,IAAI,CAACG,SAAK,IAAK;EACf,IAAI,CAACF,KAAK,CAACD,IAAI,CAACmI,UAAU,EAAEnI,IAAI,CAAC;EACjC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACc,cAAc,EAAEd,IAAI,CAAC;EACrC,IAAI,CAACG,SAAK,IAAK;AACjB;AAEO,SAASiI,QAAQ,CAAgBpI,IAAgB,EAAE;EACxD,IAAIA,IAAI,CAACkF,IAAI,KAAK,MAAM,EAAE;IACxB,IAAI,CAAC/E,SAAK,IAAK;EACjB,CAAC,MAAM;IACL,IAAI,CAACA,SAAK,IAAK;EACjB;AACF;AAEO,SAASkI,kBAAkB,GAAgB;EAChD,IAAI,CAACvI,IAAI,CAAC,MAAM,CAAC;AACnB;AAEO,SAASwI,iBAAiB,CAAgBtI,IAAyB,EAAE;EAC1E,IAAI,CAACC,KAAK,CAACD,IAAI,CAACuI,UAAU,EAAEvI,IAAI,EAAE,IAAI,CAAC;EACvC,IAAI,CAACG,SAAK,IAAK;EACf,IAAI,CAACF,KAAK,CAACD,IAAI,CAACwI,SAAS,EAAExI,IAAI,CAAC;EAChC,IAAI,CAACG,SAAK,IAAK;AACjB;AAEO,SAASsI,yBAAyB,CAEvCzI,IAAiC,EACjC;EACA,IAAI,CAACC,KAAK,CAACD,IAAI,CAACuI,UAAU,EAAEvI,IAAI,CAAC;EACjC,IAAIA,IAAI,CAAC0E,QAAQ,EAAE;IACjB,IAAI,CAACvE,KAAK,CAAC,IAAI,CAAC;EAClB;EACA,IAAI,CAACA,SAAK,IAAK;EACf,IAAI,CAACF,KAAK,CAACD,IAAI,CAACwI,SAAS,EAAExI,IAAI,CAAC;EAChC,IAAI,CAACG,SAAK,IAAK;AACjB","names":["isDeclareExportDeclaration","isStatement","AnyTypeAnnotation","word","ArrayTypeAnnotation","node","print","elementType","token","BooleanTypeAnnotation","BooleanLiteralTypeAnnotation","value","NullLiteralTypeAnnotation","DeclareClass","parent","space","_interfaceish","DeclareFunction","id","typeAnnotation","predicate","semicolon","InferredPredicate","DeclaredPredicate","DeclareInterface","InterfaceDeclaration","DeclareModule","body","DeclareModuleExports","DeclareTypeAlias","TypeAlias","DeclareOpaqueType","OpaqueType","DeclareVariable","DeclareExportDeclaration","default","FlowExportDeclaration","call","DeclareExportAllDeclaration","ExportAllDeclaration","EnumDeclaration","enumExplicitType","context","name","hasExplicitType","enumBody","members","indent","newline","member","hasUnknownMembers","dedent","EnumBooleanBody","explicitType","EnumNumberBody","EnumStringBody","EnumSymbolBody","EnumDefaultedMember","enumInitializedMember","init","EnumBooleanMember","EnumNumberMember","EnumStringMember","declaration","declar","specifiers","length","printList","source","ExistsTypeAnnotation","FunctionTypeAnnotation","typeParameters","this","params","rest","type","method","returnType","FunctionTypeParam","optional","InterfaceExtends","extends","_node$extends","mixins","implements","_variance","variance","kind","andSeparator","InterfaceTypeAnnotation","IntersectionTypeAnnotation","printJoin","types","separator","MixedTypeAnnotation","EmptyTypeAnnotation","NullableTypeAnnotation","NumberTypeAnnotation","StringTypeAnnotation","ThisTypeAnnotation","TupleTypeAnnotation","TypeofTypeAnnotation","argument","right","TypeAnnotation","TypeParameterInstantiation","TypeParameter","bound","supertype","impltype","ObjectTypeAnnotation","exact","props","properties","callProperties","indexers","internalSlots","addNewlines","leading","statement","iterator","inexact","ObjectTypeInternalSlot","static","ObjectTypeCallProperty","ObjectTypeIndexer","key","ObjectTypeProperty","proto","ObjectTypeSpreadProperty","QualifiedTypeIdentifier","qualification","SymbolTypeAnnotation","orSeparator","UnionTypeAnnotation","TypeCastExpression","expression","Variance","VoidTypeAnnotation","IndexedAccessType","objectType","indexType","OptionalIndexedAccessType"],"sources":["/Users/elahehaslani/Work/Sample-Project/ticket-booking/ticket-booking/node_modules/@babel/generator/src/generators/flow.ts"],"sourcesContent":["import type Printer from \"../printer\";\nimport { isDeclareExportDeclaration, isStatement } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { ExportAllDeclaration } from \"./modules\";\n\nexport function AnyTypeAnnotation(this: Printer) {\n  this.word(\"any\");\n}\n\nexport function ArrayTypeAnnotation(\n  this: Printer,\n  node: t.ArrayTypeAnnotation,\n) {\n  this.print(node.elementType, node, true);\n  this.token(\"[\");\n  this.token(\"]\");\n}\n\nexport function BooleanTypeAnnotation(this: Printer) {\n  this.word(\"boolean\");\n}\n\nexport function BooleanLiteralTypeAnnotation(\n  this: Printer,\n  node: t.BooleanLiteralTypeAnnotation,\n) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nexport function NullLiteralTypeAnnotation(this: Printer) {\n  this.word(\"null\");\n}\n\nexport function DeclareClass(\n  this: Printer,\n  node: t.DeclareClass,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"class\");\n  this.space();\n  this._interfaceish(node);\n}\n\nexport function DeclareFunction(\n  this: Printer,\n  node: t.DeclareFunction,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"function\");\n  this.space();\n  this.print(node.id, node);\n  // @ts-ignore(Babel 7 vs Babel 8) TODO(Babel 8) Remove this comment, since we'll remove the Noop node\n  this.print(node.id.typeAnnotation.typeAnnotation, node);\n\n  if (node.predicate) {\n    this.space();\n    this.print(node.predicate, node);\n  }\n\n  this.semicolon();\n}\n\nexport function InferredPredicate(this: Printer) {\n  this.token(\"%\");\n  this.word(\"checks\");\n}\n\nexport function DeclaredPredicate(this: Printer, node: t.DeclaredPredicate) {\n  this.token(\"%\");\n  this.word(\"checks\");\n  this.token(\"(\");\n  this.print(node.value, node);\n  this.token(\")\");\n}\n\nexport function DeclareInterface(this: Printer, node: t.DeclareInterface) {\n  this.word(\"declare\");\n  this.space();\n  this.InterfaceDeclaration(node);\n}\n\nexport function DeclareModule(this: Printer, node: t.DeclareModule) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.space();\n  this.print(node.id, node);\n  this.space();\n  this.print(node.body, node);\n}\n\nexport function DeclareModuleExports(\n  this: Printer,\n  node: t.DeclareModuleExports,\n) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.token(\".\");\n  this.word(\"exports\");\n  this.print(node.typeAnnotation, node);\n}\n\nexport function DeclareTypeAlias(this: Printer, node: t.DeclareTypeAlias) {\n  this.word(\"declare\");\n  this.space();\n  this.TypeAlias(node);\n}\n\nexport function DeclareOpaqueType(\n  this: Printer,\n  node: t.DeclareOpaqueType,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.OpaqueType(node);\n}\n\nexport function DeclareVariable(\n  this: Printer,\n  node: t.DeclareVariable,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"var\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.id.typeAnnotation, node);\n  this.semicolon();\n}\n\nexport function DeclareExportDeclaration(\n  this: Printer,\n  node: t.DeclareExportDeclaration,\n) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"export\");\n  this.space();\n  if (node.default) {\n    this.word(\"default\");\n    this.space();\n  }\n\n  FlowExportDeclaration.call(this, node);\n}\n\nexport function DeclareExportAllDeclaration(\n  this: Printer,\n  node: t.DeclareExportAllDeclaration,\n) {\n  this.word(\"declare\");\n  this.space();\n  ExportAllDeclaration.call(this, node);\n}\n\nexport function EnumDeclaration(this: Printer, node: t.EnumDeclaration) {\n  const { id, body } = node;\n  this.word(\"enum\");\n  this.space();\n  this.print(id, node);\n  this.print(body, node);\n}\n\nfunction enumExplicitType(\n  context: Printer,\n  name: string,\n  hasExplicitType: boolean,\n) {\n  if (hasExplicitType) {\n    context.space();\n    context.word(\"of\");\n    context.space();\n    context.word(name);\n  }\n  context.space();\n}\n\nfunction enumBody(context: Printer, node: t.EnumBody) {\n  const { members } = node;\n  context.token(\"{\");\n  context.indent();\n  context.newline();\n  for (const member of members) {\n    context.print(member, node);\n    context.newline();\n  }\n  if (node.hasUnknownMembers) {\n    context.token(\"...\");\n    context.newline();\n  }\n  context.dedent();\n  context.token(\"}\");\n}\n\nexport function EnumBooleanBody(this: Printer, node: t.EnumBooleanBody) {\n  const { explicitType } = node;\n  enumExplicitType(this, \"boolean\", explicitType);\n  enumBody(this, node);\n}\n\nexport function EnumNumberBody(this: Printer, node: t.EnumNumberBody) {\n  const { explicitType } = node;\n  enumExplicitType(this, \"number\", explicitType);\n  enumBody(this, node);\n}\n\nexport function EnumStringBody(this: Printer, node: t.EnumStringBody) {\n  const { explicitType } = node;\n  enumExplicitType(this, \"string\", explicitType);\n  enumBody(this, node);\n}\n\nexport function EnumSymbolBody(this: Printer, node: t.EnumSymbolBody) {\n  enumExplicitType(this, \"symbol\", true);\n  enumBody(this, node);\n}\n\nexport function EnumDefaultedMember(\n  this: Printer,\n  node: t.EnumDefaultedMember,\n) {\n  const { id } = node;\n  this.print(id, node);\n  this.token(\",\");\n}\n\nfunction enumInitializedMember(\n  context: Printer,\n  node: t.EnumBooleanMember | t.EnumNumberMember | t.EnumStringMember,\n) {\n  const { id, init } = node;\n  context.print(id, node);\n  context.space();\n  context.token(\"=\");\n  context.space();\n  context.print(init, node);\n  context.token(\",\");\n}\n\nexport function EnumBooleanMember(this: Printer, node: t.EnumBooleanMember) {\n  enumInitializedMember(this, node);\n}\n\nexport function EnumNumberMember(this: Printer, node: t.EnumNumberMember) {\n  enumInitializedMember(this, node);\n}\n\nexport function EnumStringMember(this: Printer, node: t.EnumStringMember) {\n  enumInitializedMember(this, node);\n}\n\nfunction FlowExportDeclaration(\n  this: Printer,\n  node: t.DeclareExportDeclaration,\n) {\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar, node);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    this.token(\"{\");\n    if (node.specifiers.length) {\n      this.space();\n      this.printList(node.specifiers, node);\n      this.space();\n    }\n    this.token(\"}\");\n\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      this.print(node.source, node);\n    }\n\n    this.semicolon();\n  }\n}\n\nexport function ExistsTypeAnnotation(this: Printer) {\n  this.token(\"*\");\n}\n\nexport function FunctionTypeAnnotation(\n  this: Printer,\n  node: t.FunctionTypeAnnotation,\n  parent: t.Node | void,\n) {\n  this.print(node.typeParameters, node);\n  this.token(\"(\");\n\n  if (node.this) {\n    this.word(\"this\");\n    this.token(\":\");\n    this.space();\n    this.print(node.this.typeAnnotation, node);\n    if (node.params.length || node.rest) {\n      this.token(\",\");\n      this.space();\n    }\n  }\n\n  this.printList(node.params, node);\n\n  if (node.rest) {\n    if (node.params.length) {\n      this.token(\",\");\n      this.space();\n    }\n    this.token(\"...\");\n    this.print(node.rest, node);\n  }\n\n  this.token(\")\");\n\n  // this node type is overloaded, not sure why but it makes it EXTREMELY annoying\n  if (\n    parent &&\n    (parent.type === \"ObjectTypeCallProperty\" ||\n      parent.type === \"ObjectTypeInternalSlot\" ||\n      parent.type === \"DeclareFunction\" ||\n      (parent.type === \"ObjectTypeProperty\" && parent.method))\n  ) {\n    this.token(\":\");\n  } else {\n    this.space();\n    this.token(\"=>\");\n  }\n\n  this.space();\n  this.print(node.returnType, node);\n}\n\nexport function FunctionTypeParam(this: Printer, node: t.FunctionTypeParam) {\n  this.print(node.name, node);\n  if (node.optional) this.token(\"?\");\n  if (node.name) {\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.typeAnnotation, node);\n}\n\nexport function InterfaceExtends(this: Printer, node: t.InterfaceExtends) {\n  this.print(node.id, node);\n  this.print(node.typeParameters, node, true);\n}\n\nexport {\n  InterfaceExtends as ClassImplements,\n  InterfaceExtends as GenericTypeAnnotation,\n};\n\nexport function _interfaceish(\n  this: Printer,\n  node: t.InterfaceDeclaration | t.DeclareInterface | t.DeclareClass,\n) {\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  if (node.extends?.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends, node);\n  }\n  if (node.mixins && node.mixins.length) {\n    this.space();\n    this.word(\"mixins\");\n    this.space();\n    this.printList(node.mixins, node);\n  }\n  if (node.implements && node.implements.length) {\n    this.space();\n    this.word(\"implements\");\n    this.space();\n    this.printList(node.implements, node);\n  }\n  this.space();\n  this.print(node.body, node);\n}\n\nexport function _variance(\n  this: Printer,\n  node:\n    | t.TypeParameter\n    | t.ObjectTypeIndexer\n    | t.ObjectTypeProperty\n    | t.ClassProperty\n    | t.ClassPrivateProperty\n    | t.ClassAccessorProperty,\n) {\n  if (node.variance) {\n    if (node.variance.kind === \"plus\") {\n      this.token(\"+\");\n    } else if (node.variance.kind === \"minus\") {\n      this.token(\"-\");\n    }\n  }\n}\n\nexport function InterfaceDeclaration(\n  this: Printer,\n  node: t.InterfaceDeclaration | t.DeclareInterface,\n) {\n  this.word(\"interface\");\n  this.space();\n  this._interfaceish(node);\n}\n\nfunction andSeparator(this: Printer) {\n  this.space();\n  this.token(\"&\");\n  this.space();\n}\n\nexport function InterfaceTypeAnnotation(\n  this: Printer,\n  node: t.InterfaceTypeAnnotation,\n) {\n  this.word(\"interface\");\n  if (node.extends && node.extends.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends, node);\n  }\n  this.space();\n  this.print(node.body, node);\n}\n\nexport function IntersectionTypeAnnotation(\n  this: Printer,\n  node: t.IntersectionTypeAnnotation,\n) {\n  this.printJoin(node.types, node, { separator: andSeparator });\n}\n\nexport function MixedTypeAnnotation(this: Printer) {\n  this.word(\"mixed\");\n}\n\nexport function EmptyTypeAnnotation(this: Printer) {\n  this.word(\"empty\");\n}\n\nexport function NullableTypeAnnotation(\n  this: Printer,\n  node: t.NullableTypeAnnotation,\n) {\n  this.token(\"?\");\n  this.print(node.typeAnnotation, node);\n}\n\nexport {\n  NumericLiteral as NumberLiteralTypeAnnotation,\n  StringLiteral as StringLiteralTypeAnnotation,\n} from \"./types\";\n\nexport function NumberTypeAnnotation(this: Printer) {\n  this.word(\"number\");\n}\n\nexport function StringTypeAnnotation(this: Printer) {\n  this.word(\"string\");\n}\n\nexport function ThisTypeAnnotation(this: Printer) {\n  this.word(\"this\");\n}\n\nexport function TupleTypeAnnotation(\n  this: Printer,\n  node: t.TupleTypeAnnotation,\n) {\n  this.token(\"[\");\n  this.printList(node.types, node);\n  this.token(\"]\");\n}\n\nexport function TypeofTypeAnnotation(\n  this: Printer,\n  node: t.TypeofTypeAnnotation,\n) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.argument, node);\n}\n\nexport function TypeAlias(\n  this: Printer,\n  node: t.TypeAlias | t.DeclareTypeAlias,\n) {\n  this.word(\"type\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right, node);\n  this.semicolon();\n}\n\nexport function TypeAnnotation(this: Printer, node: t.TypeAnnotation) {\n  this.token(\":\");\n  this.space();\n  // @ts-expect-error todo(flow->ts) can this be removed? `.optional` looks to be not existing property\n  if (node.optional) this.token(\"?\");\n  this.print(node.typeAnnotation, node);\n}\n\nexport function TypeParameterInstantiation(\n  this: Printer,\n  node: t.TypeParameterInstantiation,\n): void {\n  this.token(\"<\");\n  this.printList(node.params, node, {});\n  this.token(\">\");\n}\n\nexport { TypeParameterInstantiation as TypeParameterDeclaration };\n\nexport function TypeParameter(this: Printer, node: t.TypeParameter) {\n  this._variance(node);\n\n  this.word(node.name);\n\n  if (node.bound) {\n    this.print(node.bound, node);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.default, node);\n  }\n}\n\nexport function OpaqueType(\n  this: Printer,\n  node: t.OpaqueType | t.DeclareOpaqueType,\n) {\n  this.word(\"opaque\");\n  this.space();\n  this.word(\"type\");\n  this.space();\n  this.print(node.id, node);\n  this.print(node.typeParameters, node);\n  if (node.supertype) {\n    this.token(\":\");\n    this.space();\n    this.print(node.supertype, node);\n  }\n\n  if (node.impltype) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.impltype, node);\n  }\n  this.semicolon();\n}\n\nexport function ObjectTypeAnnotation(\n  this: Printer,\n  node: t.ObjectTypeAnnotation,\n) {\n  if (node.exact) {\n    this.token(\"{|\");\n  } else {\n    this.token(\"{\");\n  }\n\n  // TODO: remove the array fallbacks and instead enforce the types to require an array\n  const props = [\n    ...node.properties,\n    ...(node.callProperties || []),\n    ...(node.indexers || []),\n    ...(node.internalSlots || []),\n  ];\n\n  if (props.length) {\n    this.newline();\n\n    this.space();\n\n    this.printJoin(props, node, {\n      addNewlines(leading) {\n        if (leading && !props[0]) return 1;\n      },\n      indent: true,\n      statement: true,\n      iterator: () => {\n        if (props.length !== 1 || node.inexact) {\n          this.token(\",\");\n          this.space();\n        }\n      },\n    });\n\n    this.space();\n  }\n\n  if (node.inexact) {\n    this.indent();\n    this.token(\"...\");\n    if (props.length) {\n      this.newline();\n    }\n    this.dedent();\n  }\n\n  if (node.exact) {\n    this.token(\"|}\");\n  } else {\n    this.token(\"}\");\n  }\n}\n\nexport function ObjectTypeInternalSlot(\n  this: Printer,\n  node: t.ObjectTypeInternalSlot,\n) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.token(\"[\");\n  this.token(\"[\");\n  this.print(node.id, node);\n  this.token(\"]\");\n  this.token(\"]\");\n  if (node.optional) this.token(\"?\");\n  if (!node.method) {\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.value, node);\n}\n\nexport function ObjectTypeCallProperty(\n  this: Printer,\n  node: t.ObjectTypeCallProperty,\n) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.print(node.value, node);\n}\n\nexport function ObjectTypeIndexer(this: Printer, node: t.ObjectTypeIndexer) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this._variance(node);\n  this.token(\"[\");\n  if (node.id) {\n    this.print(node.id, node);\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.key, node);\n  this.token(\"]\");\n  this.token(\":\");\n  this.space();\n  this.print(node.value, node);\n}\n\nexport function ObjectTypeProperty(this: Printer, node: t.ObjectTypeProperty) {\n  if (node.proto) {\n    this.word(\"proto\");\n    this.space();\n  }\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (node.kind === \"get\" || node.kind === \"set\") {\n    this.word(node.kind);\n    this.space();\n  }\n  this._variance(node);\n  this.print(node.key, node);\n  if (node.optional) this.token(\"?\");\n  if (!node.method) {\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.value, node);\n}\n\nexport function ObjectTypeSpreadProperty(\n  this: Printer,\n  node: t.ObjectTypeSpreadProperty,\n) {\n  this.token(\"...\");\n  this.print(node.argument, node);\n}\n\nexport function QualifiedTypeIdentifier(\n  this: Printer,\n  node: t.QualifiedTypeIdentifier,\n) {\n  this.print(node.qualification, node);\n  this.token(\".\");\n  this.print(node.id, node);\n}\n\nexport function SymbolTypeAnnotation(this: Printer) {\n  this.word(\"symbol\");\n}\n\nfunction orSeparator(this: Printer) {\n  this.space();\n  this.token(\"|\");\n  this.space();\n}\n\nexport function UnionTypeAnnotation(\n  this: Printer,\n  node: t.UnionTypeAnnotation,\n) {\n  this.printJoin(node.types, node, { separator: orSeparator });\n}\n\nexport function TypeCastExpression(this: Printer, node: t.TypeCastExpression) {\n  this.token(\"(\");\n  this.print(node.expression, node);\n  this.print(node.typeAnnotation, node);\n  this.token(\")\");\n}\n\nexport function Variance(this: Printer, node: t.Variance) {\n  if (node.kind === \"plus\") {\n    this.token(\"+\");\n  } else {\n    this.token(\"-\");\n  }\n}\n\nexport function VoidTypeAnnotation(this: Printer) {\n  this.word(\"void\");\n}\n\nexport function IndexedAccessType(this: Printer, node: t.IndexedAccessType) {\n  this.print(node.objectType, node, true);\n  this.token(\"[\");\n  this.print(node.indexType, node);\n  this.token(\"]\");\n}\n\nexport function OptionalIndexedAccessType(\n  this: Printer,\n  node: t.OptionalIndexedAccessType,\n) {\n  this.print(node.objectType, node);\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n  this.token(\"[\");\n  this.print(node.indexType, node);\n  this.token(\"]\");\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}