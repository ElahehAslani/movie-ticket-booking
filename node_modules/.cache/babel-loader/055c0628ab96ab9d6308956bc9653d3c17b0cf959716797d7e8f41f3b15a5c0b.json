{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExportAllDeclaration = ExportAllDeclaration;\nexports.ExportDefaultDeclaration = ExportDefaultDeclaration;\nexports.ExportDefaultSpecifier = ExportDefaultSpecifier;\nexports.ExportNamedDeclaration = ExportNamedDeclaration;\nexports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;\nexports.ExportSpecifier = ExportSpecifier;\nexports.ImportAttribute = ImportAttribute;\nexports.ImportDeclaration = ImportDeclaration;\nexports.ImportDefaultSpecifier = ImportDefaultSpecifier;\nexports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;\nexports.ImportSpecifier = ImportSpecifier;\nexports._printAssertions = _printAssertions;\nvar _t = require(\"@babel/types\");\nconst {\n  isClassDeclaration,\n  isExportDefaultSpecifier,\n  isExportNamespaceSpecifier,\n  isImportDefaultSpecifier,\n  isImportNamespaceSpecifier,\n  isStatement\n} = _t;\nfunction ImportSpecifier(node) {\n  if (node.importKind === \"type\" || node.importKind === \"typeof\") {\n    this.word(node.importKind);\n    this.space();\n  }\n  this.print(node.imported, node);\n  if (node.local && node.local.name !== node.imported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.local, node);\n  }\n}\nfunction ImportDefaultSpecifier(node) {\n  this.print(node.local, node);\n}\nfunction ExportDefaultSpecifier(node) {\n  this.print(node.exported, node);\n}\nfunction ExportSpecifier(node) {\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n  this.print(node.local, node);\n  if (node.exported && node.local.name !== node.exported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.exported, node);\n  }\n}\nfunction ExportNamespaceSpecifier(node) {\n  this.tokenChar(42);\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.exported, node);\n}\nfunction _printAssertions(node) {\n  this.word(\"assert\");\n  this.space();\n  this.tokenChar(123);\n  this.space();\n  this.printList(node.assertions, node);\n  this.space();\n  this.tokenChar(125);\n}\nfunction ExportAllDeclaration(node) {\n  var _node$assertions;\n  this.word(\"export\");\n  this.space();\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n  this.tokenChar(42);\n  this.space();\n  this.word(\"from\");\n  this.space();\n  if ((_node$assertions = node.assertions) != null && _node$assertions.length) {\n    this.print(node.source, node, true);\n    this.space();\n    this._printAssertions(node);\n  } else {\n    this.print(node.source, node);\n  }\n  this.semicolon();\n}\nfunction ExportNamedDeclaration(node) {\n  {\n    if (this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration)) {\n      this.printJoin(node.declaration.decorators, node);\n    }\n  }\n  this.word(\"export\");\n  this.space();\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar, node);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    if (node.exportKind === \"type\") {\n      this.word(\"type\");\n      this.space();\n    }\n    const specifiers = node.specifiers.slice(0);\n    let hasSpecial = false;\n    for (;;) {\n      const first = specifiers[0];\n      if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {\n        hasSpecial = true;\n        this.print(specifiers.shift(), node);\n        if (specifiers.length) {\n          this.tokenChar(44);\n          this.space();\n        }\n      } else {\n        break;\n      }\n    }\n    if (specifiers.length || !specifiers.length && !hasSpecial) {\n      this.tokenChar(123);\n      if (specifiers.length) {\n        this.space();\n        this.printList(specifiers, node);\n        this.space();\n      }\n      this.tokenChar(125);\n    }\n    if (node.source) {\n      var _node$assertions2;\n      this.space();\n      this.word(\"from\");\n      this.space();\n      if ((_node$assertions2 = node.assertions) != null && _node$assertions2.length) {\n        this.print(node.source, node, true);\n        this.space();\n        this._printAssertions(node);\n      } else {\n        this.print(node.source, node);\n      }\n    }\n    this.semicolon();\n  }\n}\nfunction ExportDefaultDeclaration(node) {\n  {\n    if (this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration)) {\n      this.printJoin(node.declaration.decorators, node);\n    }\n  }\n  this.word(\"export\");\n  this.noIndentInnerCommentsHere();\n  this.space();\n  this.word(\"default\");\n  this.space();\n  const declar = node.declaration;\n  this.print(declar, node);\n  if (!isStatement(declar)) this.semicolon();\n}\nfunction ImportDeclaration(node) {\n  var _node$assertions3;\n  this.word(\"import\");\n  this.space();\n  const isTypeKind = node.importKind === \"type\" || node.importKind === \"typeof\";\n  if (isTypeKind) {\n    this.noIndentInnerCommentsHere();\n    this.word(node.importKind);\n    this.space();\n  } else if (node.module) {\n    this.noIndentInnerCommentsHere();\n    this.word(\"module\");\n    this.space();\n  }\n  const specifiers = node.specifiers.slice(0);\n  const hasSpecifiers = !!specifiers.length;\n  while (hasSpecifiers) {\n    const first = specifiers[0];\n    if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {\n      this.print(specifiers.shift(), node);\n      if (specifiers.length) {\n        this.tokenChar(44);\n        this.space();\n      }\n    } else {\n      break;\n    }\n  }\n  if (specifiers.length) {\n    this.tokenChar(123);\n    this.space();\n    this.printList(specifiers, node);\n    this.space();\n    this.tokenChar(125);\n  } else if (isTypeKind && !hasSpecifiers) {\n    this.tokenChar(123);\n    this.tokenChar(125);\n  }\n  if (hasSpecifiers || isTypeKind) {\n    this.space();\n    this.word(\"from\");\n    this.space();\n  }\n  if ((_node$assertions3 = node.assertions) != null && _node$assertions3.length) {\n    this.print(node.source, node, true);\n    this.space();\n    this._printAssertions(node);\n  } else {\n    this.print(node.source, node);\n  }\n  {\n    var _node$attributes;\n    if ((_node$attributes = node.attributes) != null && _node$attributes.length) {\n      this.space();\n      this.word(\"with\");\n      this.space();\n      this.printList(node.attributes, node);\n    }\n  }\n  this.semicolon();\n}\nfunction ImportAttribute(node) {\n  this.print(node.key);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.value);\n}\nfunction ImportNamespaceSpecifier(node) {\n  this.tokenChar(42);\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.local, node);\n}","map":{"version":3,"mappings":"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","names":["isClassDeclaration","isExportDefaultSpecifier","isExportNamespaceSpecifier","isImportDefaultSpecifier","isImportNamespaceSpecifier","isStatement","ImportSpecifier","node","importKind","word","space","print","imported","local","name","ImportDefaultSpecifier","ExportDefaultSpecifier","exported","ExportSpecifier","exportKind","ExportNamespaceSpecifier","token","_printAssertions","printList","assertions","ExportAllDeclaration","_node$assertions","length","source","semicolon","ExportNamedDeclaration","format","decoratorsBeforeExport","declaration","printJoin","decorators","declar","specifiers","slice","hasSpecial","first","shift","_node$assertions2","ExportDefaultDeclaration","noIndentInnerCommentsHere","ImportDeclaration","isTypeKind","module","hasSpecifiers","_node$assertions3","attributes","_node$attributes","ImportAttribute","key","value","ImportNamespaceSpecifier"],"sources":["/Users/elahehaslani/Work/Sample-Project/ticket-booking/ticket-booking/node_modules/@babel/generator/src/generators/modules.ts"],"sourcesContent":["import type Printer from \"../printer\";\nimport {\n  isClassDeclaration,\n  isExportDefaultSpecifier,\n  isExportNamespaceSpecifier,\n  isImportDefaultSpecifier,\n  isImportNamespaceSpecifier,\n  isStatement,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nexport function ImportSpecifier(this: Printer, node: t.ImportSpecifier) {\n  if (node.importKind === \"type\" || node.importKind === \"typeof\") {\n    this.word(node.importKind);\n    this.space();\n  }\n\n  this.print(node.imported, node);\n  // @ts-expect-error todo(flow-ts) maybe check node type instead of relying on name to be undefined on t.StringLiteral\n  if (node.local && node.local.name !== node.imported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.local, node);\n  }\n}\n\nexport function ImportDefaultSpecifier(\n  this: Printer,\n  node: t.ImportDefaultSpecifier,\n) {\n  this.print(node.local, node);\n}\n\nexport function ExportDefaultSpecifier(\n  this: Printer,\n  node: t.ExportDefaultSpecifier,\n) {\n  this.print(node.exported, node);\n}\n\nexport function ExportSpecifier(this: Printer, node: t.ExportSpecifier) {\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n\n  this.print(node.local, node);\n  // @ts-expect-error todo(flow-ts) maybe check node type instead of relying on name to be undefined on t.StringLiteral\n  if (node.exported && node.local.name !== node.exported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.exported, node);\n  }\n}\n\nexport function ExportNamespaceSpecifier(\n  this: Printer,\n  node: t.ExportNamespaceSpecifier,\n) {\n  this.token(\"*\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.exported, node);\n}\n\nexport function _printAssertions(\n  this: Printer,\n  node: Extract<t.Node, { assertions?: t.ImportAttribute[] }>,\n) {\n  this.word(\"assert\");\n  this.space();\n  this.token(\"{\");\n  this.space();\n  this.printList(node.assertions, node);\n  this.space();\n  this.token(\"}\");\n}\n\nexport function ExportAllDeclaration(\n  this: Printer,\n  node: t.ExportAllDeclaration | t.DeclareExportAllDeclaration,\n) {\n  this.word(\"export\");\n  this.space();\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n  this.token(\"*\");\n  this.space();\n  this.word(\"from\");\n  this.space();\n  // @ts-expect-error Fixme: assertions is not defined in DeclareExportAllDeclaration\n  if (node.assertions?.length) {\n    this.print(node.source, node, true);\n    this.space();\n    // @ts-expect-error Fixme: assertions is not defined in DeclareExportAllDeclaration\n    this._printAssertions(node);\n  } else {\n    this.print(node.source, node);\n  }\n\n  this.semicolon();\n}\n\nexport function ExportNamedDeclaration(\n  this: Printer,\n  node: t.ExportNamedDeclaration,\n) {\n  if (!process.env.BABEL_8_BREAKING) {\n    if (\n      this.format.decoratorsBeforeExport &&\n      isClassDeclaration(node.declaration)\n    ) {\n      this.printJoin(node.declaration.decorators, node);\n    }\n  }\n\n  this.word(\"export\");\n  this.space();\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar, node);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    if (node.exportKind === \"type\") {\n      this.word(\"type\");\n      this.space();\n    }\n\n    const specifiers = node.specifiers.slice(0);\n\n    // print \"special\" specifiers first\n    let hasSpecial = false;\n    for (;;) {\n      const first = specifiers[0];\n      if (\n        isExportDefaultSpecifier(first) ||\n        isExportNamespaceSpecifier(first)\n      ) {\n        hasSpecial = true;\n        this.print(specifiers.shift(), node);\n        if (specifiers.length) {\n          this.token(\",\");\n          this.space();\n        }\n      } else {\n        break;\n      }\n    }\n\n    if (specifiers.length || (!specifiers.length && !hasSpecial)) {\n      this.token(\"{\");\n      if (specifiers.length) {\n        this.space();\n        this.printList(specifiers, node);\n        this.space();\n      }\n      this.token(\"}\");\n    }\n\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      if (node.assertions?.length) {\n        this.print(node.source, node, true);\n        this.space();\n        this._printAssertions(node);\n      } else {\n        this.print(node.source, node);\n      }\n    }\n\n    this.semicolon();\n  }\n}\n\nexport function ExportDefaultDeclaration(\n  this: Printer,\n  node: t.ExportDefaultDeclaration,\n) {\n  if (!process.env.BABEL_8_BREAKING) {\n    if (\n      this.format.decoratorsBeforeExport &&\n      isClassDeclaration(node.declaration)\n    ) {\n      this.printJoin(node.declaration.decorators, node);\n    }\n  }\n\n  this.word(\"export\");\n  this.noIndentInnerCommentsHere();\n  this.space();\n  this.word(\"default\");\n  this.space();\n  const declar = node.declaration;\n  this.print(declar, node);\n  if (!isStatement(declar)) this.semicolon();\n}\n\nexport function ImportDeclaration(this: Printer, node: t.ImportDeclaration) {\n  this.word(\"import\");\n  this.space();\n\n  const isTypeKind = node.importKind === \"type\" || node.importKind === \"typeof\";\n  if (isTypeKind) {\n    this.noIndentInnerCommentsHere();\n    this.word(node.importKind);\n    this.space();\n  } else if (node.module) {\n    this.noIndentInnerCommentsHere();\n    this.word(\"module\");\n    this.space();\n  }\n\n  const specifiers = node.specifiers.slice(0);\n  const hasSpecifiers = !!specifiers.length;\n  // print \"special\" specifiers first. The loop condition is constant,\n  // but there is a \"break\" in the body.\n  while (hasSpecifiers) {\n    const first = specifiers[0];\n    if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {\n      this.print(specifiers.shift(), node);\n      if (specifiers.length) {\n        this.token(\",\");\n        this.space();\n      }\n    } else {\n      break;\n    }\n  }\n\n  if (specifiers.length) {\n    this.token(\"{\");\n    this.space();\n    this.printList(specifiers, node);\n    this.space();\n    this.token(\"}\");\n  } else if (isTypeKind && !hasSpecifiers) {\n    this.token(\"{\");\n    this.token(\"}\");\n  }\n\n  if (hasSpecifiers || isTypeKind) {\n    this.space();\n    this.word(\"from\");\n    this.space();\n  }\n\n  if (node.assertions?.length) {\n    this.print(node.source, node, true);\n    this.space();\n    this._printAssertions(node);\n  } else {\n    this.print(node.source, node);\n  }\n  if (!process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Babel 7 supports module attributes\n    if (node.attributes?.length) {\n      this.space();\n      this.word(\"with\");\n      this.space();\n      // @ts-ignore(Babel 7 vs Babel 8) Babel 7 supports module attributes\n      this.printList(node.attributes, node);\n    }\n  }\n\n  this.semicolon();\n}\n\nexport function ImportAttribute(this: Printer, node: t.ImportAttribute) {\n  this.print(node.key);\n  this.token(\":\");\n  this.space();\n  this.print(node.value);\n}\n\nexport function ImportNamespaceSpecifier(\n  this: Printer,\n  node: t.ImportNamespaceSpecifier,\n) {\n  this.token(\"*\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.local, node);\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}