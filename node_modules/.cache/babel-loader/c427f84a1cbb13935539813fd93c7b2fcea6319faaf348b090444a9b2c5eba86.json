{"ast":null,"code":"import { useEffect, useMemo, useRef, useState } from \"react\";\nimport { StringParam } from \"serialize-query-params\";\nimport { decodedParamCache } from \"./decodedParamCache\";\nimport { extendParamConfigForKeys, convertInheritedParamStringsToParams } from \"./inheritedParams\";\nimport { makeStableGetLatestDecodedValues } from \"./latestValues\";\nimport { memoSearchStringToObject } from \"./memoSearchStringToObject\";\nimport { mergeOptions } from \"./options\";\nimport { useQueryParamContext } from \"./QueryParamProvider\";\nimport { enqueueUpdate } from \"./updateSearchString\";\nimport { serializeUrlNameMap } from \"./urlName\";\nfunction useQueryParams(arg1, arg2) {\n  const {\n    adapter,\n    options: contextOptions\n  } = useQueryParamContext();\n  const [stableGetLatest] = useState(makeStableGetLatestDecodedValues);\n  const {\n    paramConfigMap: paramConfigMapWithInherit,\n    options\n  } = parseArguments(arg1, arg2);\n  const mergedOptions = useMemo(() => {\n    return mergeOptions(contextOptions, options);\n  }, [contextOptions, options]);\n  let paramConfigMap = convertInheritedParamStringsToParams(paramConfigMapWithInherit, mergedOptions);\n  const parsedParams = memoSearchStringToObject(mergedOptions.searchStringToObject, adapter.location.search, serializeUrlNameMap(paramConfigMap));\n  if (mergedOptions.includeAllParams) {\n    paramConfigMap = extendParamConfigForKeys(paramConfigMap, Object.keys(parsedParams), mergedOptions.params, StringParam);\n  }\n  const decodedValues = stableGetLatest(parsedParams, paramConfigMap, decodedParamCache);\n  const paramKeyString = Object.keys(paramConfigMap).join(\"\\0\");\n  useEffect(() => {\n    const paramNames = paramKeyString.split(\"\\0\");\n    decodedParamCache.registerParams(paramNames);\n    return () => {\n      decodedParamCache.unregisterParams(paramNames);\n    };\n  }, [paramKeyString]);\n  const callbackDependencies = {\n    adapter,\n    paramConfigMap,\n    options: mergedOptions\n  };\n  const callbackDependenciesRef = useRef(callbackDependencies);\n  if (callbackDependenciesRef.current == null) {\n    callbackDependenciesRef.current = callbackDependencies;\n  }\n  useEffect(() => {\n    callbackDependenciesRef.current.adapter = adapter;\n    callbackDependenciesRef.current.paramConfigMap = paramConfigMap;\n    callbackDependenciesRef.current.options = mergedOptions;\n  }, [adapter, paramConfigMap, mergedOptions]);\n  const [setQuery] = useState(() => {\n    const setQuery2 = (changes, updateType) => {\n      const {\n        adapter: adapter2,\n        paramConfigMap: paramConfigMap2,\n        options: options2\n      } = callbackDependenciesRef.current;\n      if (updateType == null) updateType = options2.updateType;\n      enqueueUpdate({\n        changes,\n        updateType,\n        currentSearchString: adapter2.location.search,\n        paramConfigMap: paramConfigMap2,\n        options: options2,\n        adapter: adapter2\n      }, {\n        immediate: !options2.enableBatching\n      });\n    };\n    return setQuery2;\n  });\n  return [decodedValues, setQuery];\n}\nvar useQueryParams_default = useQueryParams;\nfunction parseArguments(arg1, arg2) {\n  let paramConfigMap;\n  let options;\n  if (arg1 === void 0) {\n    paramConfigMap = {};\n    options = arg2;\n  } else if (Array.isArray(arg1)) {\n    paramConfigMap = Object.fromEntries(arg1.map(key => [key, \"inherit\"]));\n    options = arg2;\n  } else {\n    paramConfigMap = arg1;\n    options = arg2;\n  }\n  return {\n    paramConfigMap,\n    options\n  };\n}\nexport { useQueryParams_default as default, useQueryParams };","map":{"version":3,"mappings":"AAAA,SAASA,WAAWC,SAASC,QAAQC,gBAAgB;AACrD,SAIEC,mBACK;AACP,SAASC,yBAAyB;AAClC,SACEC,0BACAC,4CACK;AACP,SAASC,wCAAwC;AACjD,SAASC,gCAAgC;AACzC,SAASC,oBAAuC;AAChD,SAASC,4BAA4B;AAMrC,SAASC,qBAAqB;AAC9B,SAASC,2BAA2B;AAqC7B,SAASC,eACdC,MACAC,MAC2B;EAC3B,MAAM;IAAEC;IAASC,SAASC;EAAe,IAAIR,sBAAqB;EAClE,MAAM,CAACS,eAAe,IAAIjB,SAASK,gCAAgC;EAGnE,MAAM;IAAEa,gBAAgBC;IAA2BJ;EAAQ,IAAIK,eAC7DR,MACAC,KACF;EAEA,MAAMQ,gBAAgBvB,QAAQ,MAAM;IAClC,OAAOS,aAAaS,gBAAgBD,OAAO;EAC7C,GAAG,CAACC,gBAAgBD,OAAO,CAAC;EAG5B,IAAIG,iBAAiBd,qCACnBe,2BACAE,cACF;EAGA,MAAMC,eAAehB,yBACnBe,cAAcE,sBACdT,QAAQU,SAASC,QACjBf,oBAAoBQ,cAAc,EACpC;EAGA,IAAIG,cAAcK,kBAAkB;IAClCR,iBAAiBf,yBACfe,gBACAS,OAAOC,KAAKN,YAAY,GACxBD,cAAcQ,QACd5B,YACF;EACF;EAGA,MAAM6B,gBAAgBb,gBACpBK,cACAJ,gBACAhB,kBACF;EAIA,MAAM6B,iBAAiBJ,OAAOC,KAAKV,cAAc,EAAEc,KAAK,IAAI;EAC5DnC,UAAU,MAAM;IACd,MAAMoC,aAAaF,eAAeG,MAAM,IAAI;IAC5ChC,kBAAkBiC,eAAeF,UAAU;IAC3C,OAAO,MAAM;MACX/B,kBAAkBkC,iBAAiBH,UAAU;IAC/C;EACF,GAAG,CAACF,cAAc,CAAC;EAInB,MAAMM,uBAAuB;IAC3BvB;IACAI;IACAH,SAASM;EACX;EACA,MAAMiB,0BACJvC,OAAoCsC,oBAAoB;EAC1D,IAAIC,wBAAwBC,WAAW,MAAM;IAC3CD,wBAAwBC,UAAUF;EACpC;EACAxC,UAAU,MAAM;IACdyC,wBAAwBC,QAAQzB,UAAUA;IAC1CwB,wBAAwBC,QAAQrB,iBAAiBA;IACjDoB,wBAAwBC,QAAQxB,UAAUM;EAC5C,GAAG,CAACP,SAASI,gBAAgBG,aAAa,CAAC;EAG3C,MAAM,CAACmB,QAAQ,IAAIxC,SAAS,MAAM;IAChC,MAAMwC,YAAW,CACfC,SACAC,eACG;MAEH,MAAM;QAAE5B;QAASI;QAAgBH;MAAQ,IACvCuB,wBAAwBC;MAC1B,IAAIG,cAAc,MAAMA,aAAa3B,SAAQ2B;MAE7CjC,cACE;QACEgC;QACAC;QACAC,qBAAqB7B,SAAQU,SAASC;QACtCP;QACAH;QACAD;MACF,GACA;QAAE8B,WAAW,CAAC7B,SAAQ8B;MAAe,EACvC;IACF;IAEA,OAAOL;EACT,CAAC;EAED,OAAO,CAACV,eAAeU,QAAQ;AACjC;AAEA,IAAOM,yBAAQnC;AAEf,SAASS,eACPR,MACAC,MAIA;EACA,IAAIK;EACJ,IAAIH;EAEJ,IAAIH,SAAS,QAAW;IAEtBM,iBAAiB,CAAC;IAClBH,UAAUF;EACZ,WAAWkC,MAAMC,QAAQpC,IAAI,GAAG;IAG9BM,iBAAiBS,OAAOsB,YACtBrC,KAAKsC,IAAKC,OAAQ,CAACA,KAAK,SAAkB,CAAC,EAC7C;IACApC,UAAUF;EACZ,OAAO;IAGLK,iBAAiBN;IACjBG,UAAUF;EACZ;EAEA,OAAO;IAAEK;IAAgBH;EAAQ;AACnC","names":["useEffect","useMemo","useRef","useState","StringParam","decodedParamCache","extendParamConfigForKeys","convertInheritedParamStringsToParams","makeStableGetLatestDecodedValues","memoSearchStringToObject","mergeOptions","useQueryParamContext","enqueueUpdate","serializeUrlNameMap","useQueryParams","arg1","arg2","adapter","options","contextOptions","stableGetLatest","paramConfigMap","paramConfigMapWithInherit","parseArguments","mergedOptions","parsedParams","searchStringToObject","location","search","includeAllParams","Object","keys","params","decodedValues","paramKeyString","join","paramNames","split","registerParams","unregisterParams","callbackDependencies","callbackDependenciesRef","current","setQuery","changes","updateType","currentSearchString","immediate","enableBatching","useQueryParams_default","Array","isArray","fromEntries","map","key"],"sources":["/Users/elahehaslani/Documents/GitHub/movie-ticket-booking/node_modules/use-query-params/src/useQueryParams.ts"],"sourcesContent":["import { useEffect, useMemo, useRef, useState } from 'react';\nimport {\n  DecodedValueMap,\n  QueryParamConfig,\n  QueryParamConfigMap,\n  StringParam,\n} from 'serialize-query-params';\nimport { decodedParamCache } from './decodedParamCache';\nimport {\n  extendParamConfigForKeys,\n  convertInheritedParamStringsToParams,\n} from './inheritedParams';\nimport { makeStableGetLatestDecodedValues } from './latestValues';\nimport { memoSearchStringToObject } from './memoSearchStringToObject';\nimport { mergeOptions, QueryParamOptions } from './options';\nimport { useQueryParamContext } from './QueryParamProvider';\nimport {\n  QueryParamConfigMapWithInherit,\n  SetQuery,\n  UrlUpdateType,\n} from './types';\nimport { enqueueUpdate } from './updateSearchString';\nimport { serializeUrlNameMap } from './urlName';\n\n// for multiple param config\ntype ChangesType<DecodedValueMapType> =\n  | Partial<DecodedValueMapType>\n  | ((latestValues: DecodedValueMapType) => Partial<DecodedValueMapType>);\n\ntype UseQueryParamsResult<QPCMap extends QueryParamConfigMap> = [\n  DecodedValueMap<QPCMap>,\n  SetQuery<QPCMap>\n];\ntype ExpandInherits<QPCMap extends QueryParamConfigMapWithInherit> = {\n  [ParamName in keyof QPCMap]: QPCMap[ParamName] extends string\n    ? typeof StringParam\n    : QPCMap[ParamName] extends QueryParamConfig<any>\n    ? QPCMap[ParamName]\n    : never;\n};\n\n/**\n * Given a query parameter configuration (mapping query param name to { encode, decode }),\n * return an object with the decoded values and a setter for updating them.\n */\nexport function useQueryParams<\n  QPCMap extends QueryParamConfigMap = QueryParamConfigMap\n>(): UseQueryParamsResult<QPCMap>;\nexport function useQueryParams<QPCMap extends QueryParamConfigMapWithInherit>(\n  names: string[],\n  options?: QueryParamOptions\n): UseQueryParamsResult<ExpandInherits<QPCMap>>;\nexport function useQueryParams<\n  QPCMap extends QueryParamConfigMapWithInherit,\n  OutputQPCMap extends QueryParamConfigMap = ExpandInherits<QPCMap>\n>(\n  paramConfigMap: QPCMap,\n  options?: QueryParamOptions\n): UseQueryParamsResult<OutputQPCMap>;\nexport function useQueryParams(\n  arg1?: string[] | QueryParamConfigMapWithInherit,\n  arg2?: QueryParamConfig<any> | QueryParamOptions\n): UseQueryParamsResult<any> {\n  const { adapter, options: contextOptions } = useQueryParamContext();\n  const [stableGetLatest] = useState(makeStableGetLatestDecodedValues);\n\n  // intepret the overloaded arguments\n  const { paramConfigMap: paramConfigMapWithInherit, options } = parseArguments(\n    arg1,\n    arg2\n  );\n\n  const mergedOptions = useMemo(() => {\n    return mergeOptions(contextOptions, options);\n  }, [contextOptions, options]);\n\n  // interpret params that were configured up the chain\n  let paramConfigMap = convertInheritedParamStringsToParams(\n    paramConfigMapWithInherit,\n    mergedOptions\n  );\n\n  // what is the current stringified value?\n  const parsedParams = memoSearchStringToObject(\n    mergedOptions.searchStringToObject,\n    adapter.location.search,\n    serializeUrlNameMap(paramConfigMap) // note we serialize for memo purposes\n  );\n\n  // do we want to include all params from the URL even if not configured?\n  if (mergedOptions.includeAllParams) {\n    paramConfigMap = extendParamConfigForKeys(\n      paramConfigMap,\n      Object.keys(parsedParams),\n      mergedOptions.params,\n      StringParam\n    );\n  }\n\n  // run decode on each key\n  const decodedValues = stableGetLatest(\n    parsedParams,\n    paramConfigMap,\n    decodedParamCache\n  );\n\n  // clear out unused values in cache\n  // use string for relatively stable effect dependency\n  const paramKeyString = Object.keys(paramConfigMap).join('\\0');\n  useEffect(() => {\n    const paramNames = paramKeyString.split('\\0');\n    decodedParamCache.registerParams(paramNames);\n    return () => {\n      decodedParamCache.unregisterParams(paramNames);\n    };\n  }, [paramKeyString]);\n\n  // create a setter for updating multiple query params at once\n  // use a ref for callback dependencies so we don't generate a new one unnecessarily\n  const callbackDependencies = {\n    adapter,\n    paramConfigMap,\n    options: mergedOptions,\n  };\n  const callbackDependenciesRef =\n    useRef<typeof callbackDependencies>(callbackDependencies);\n  if (callbackDependenciesRef.current == null) {\n    callbackDependenciesRef.current = callbackDependencies;\n  }\n  useEffect(() => {\n    callbackDependenciesRef.current.adapter = adapter;\n    callbackDependenciesRef.current.paramConfigMap = paramConfigMap;\n    callbackDependenciesRef.current.options = mergedOptions;\n  }, [adapter, paramConfigMap, mergedOptions]);\n\n  // create callback with stable identity\n  const [setQuery] = useState(() => {\n    const setQuery = (\n      changes: ChangesType<DecodedValueMap<any>>,\n      updateType?: UrlUpdateType\n    ) => {\n      // read from a ref so we don't generate new setters each time any change\n      const { adapter, paramConfigMap, options } =\n        callbackDependenciesRef.current!;\n      if (updateType == null) updateType = options.updateType;\n\n      enqueueUpdate(\n        {\n          changes,\n          updateType,\n          currentSearchString: adapter.location.search,\n          paramConfigMap,\n          options,\n          adapter,\n        },\n        { immediate: !options.enableBatching }\n      );\n    };\n\n    return setQuery;\n  });\n\n  return [decodedValues, setQuery];\n}\n\nexport default useQueryParams;\n\nfunction parseArguments(\n  arg1: string[] | QueryParamConfigMapWithInherit | undefined,\n  arg2: QueryParamConfig<any> | QueryParamOptions | undefined\n): {\n  paramConfigMap: QueryParamConfigMapWithInherit;\n  options: QueryParamOptions | undefined;\n} {\n  let paramConfigMap: QueryParamConfigMapWithInherit;\n  let options: QueryParamOptions | undefined;\n\n  if (arg1 === undefined) {\n    // useQueryParams()\n    paramConfigMap = {};\n    options = arg2 as QueryParamOptions | undefined;\n  } else if (Array.isArray(arg1)) {\n    // useQueryParams(['geo', 'other'])\n    // useQueryParams(['geo', 'other'], options)\n    paramConfigMap = Object.fromEntries(\n      arg1.map((key) => [key, 'inherit' as const])\n    );\n    options = arg2 as QueryParamOptions | undefined;\n  } else {\n    // useQueryParams({ geo: NumberParam })\n    // useQueryParams({ geo: NumberParam }, options)\n    paramConfigMap = arg1;\n    options = arg2 as QueryParamOptions | undefined;\n  }\n\n  return { paramConfigMap, options };\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}