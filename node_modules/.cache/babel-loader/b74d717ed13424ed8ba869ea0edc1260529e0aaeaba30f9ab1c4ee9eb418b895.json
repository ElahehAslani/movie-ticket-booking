{"ast":null,"code":"import { decodedMappings, traceSegment, TraceMap } from '@jridgewell/trace-mapping';\nimport { GenMapping, addSegment, setSourceContent, decodedMap, encodedMap } from '@jridgewell/gen-mapping';\nconst SOURCELESS_MAPPING = {\n  source: null,\n  column: null,\n  line: null,\n  name: null,\n  content: null\n};\nconst EMPTY_SOURCES = [];\nfunction Source(map, sources, source, content) {\n  return {\n    map,\n    sources,\n    source,\n    content\n  };\n}\n/**\n * MapSource represents a single sourcemap, with the ability to trace mappings into its child nodes\n * (which may themselves be SourceMapTrees).\n */\nfunction MapSource(map, sources) {\n  return Source(map, sources, '', null);\n}\n/**\n * A \"leaf\" node in the sourcemap tree, representing an original, unmodified source file. Recursive\n * segment tracing ends at the `OriginalSource`.\n */\nfunction OriginalSource(source, content) {\n  return Source(null, EMPTY_SOURCES, source, content);\n}\n/**\n * traceMappings is only called on the root level SourceMapTree, and begins the process of\n * resolving each mapping in terms of the original source files.\n */\nfunction traceMappings(tree) {\n  const gen = new GenMapping({\n    file: tree.map.file\n  });\n  const {\n    sources: rootSources,\n    map\n  } = tree;\n  const rootNames = map.names;\n  const rootMappings = decodedMappings(map);\n  for (let i = 0; i < rootMappings.length; i++) {\n    const segments = rootMappings[i];\n    let lastSource = null;\n    let lastSourceLine = null;\n    let lastSourceColumn = null;\n    for (let j = 0; j < segments.length; j++) {\n      const segment = segments[j];\n      const genCol = segment[0];\n      let traced = SOURCELESS_MAPPING;\n      // 1-length segments only move the current generated column, there's no source information\n      // to gather from it.\n      if (segment.length !== 1) {\n        const source = rootSources[segment[1]];\n        traced = originalPositionFor(source, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : '');\n        // If the trace is invalid, then the trace ran into a sourcemap that doesn't contain a\n        // respective segment into an original source.\n        if (traced == null) continue;\n      }\n      // So we traced a segment down into its original source file. Now push a\n      // new segment pointing to this location.\n      const {\n        column,\n        line,\n        name,\n        content,\n        source\n      } = traced;\n      if (line === lastSourceLine && column === lastSourceColumn && source === lastSource) {\n        continue;\n      }\n      lastSourceLine = line;\n      lastSourceColumn = column;\n      lastSource = source;\n      // Sigh, TypeScript can't figure out source/line/column are either all null, or all non-null...\n      addSegment(gen, i, genCol, source, line, column, name);\n      if (content != null) setSourceContent(gen, source, content);\n    }\n  }\n  return gen;\n}\n/**\n * originalPositionFor is only called on children SourceMapTrees. It recurses down into its own\n * child SourceMapTrees, until we find the original source map.\n */\nfunction originalPositionFor(source, line, column, name) {\n  if (!source.map) {\n    return {\n      column,\n      line,\n      name,\n      source: source.source,\n      content: source.content\n    };\n  }\n  const segment = traceSegment(source.map, line, column);\n  // If we couldn't find a segment, then this doesn't exist in the sourcemap.\n  if (segment == null) return null;\n  // 1-length segments only move the current generated column, there's no source information\n  // to gather from it.\n  if (segment.length === 1) return SOURCELESS_MAPPING;\n  return originalPositionFor(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name);\n}\nfunction asArray(value) {\n  if (Array.isArray(value)) return value;\n  return [value];\n}\n/**\n * Recursively builds a tree structure out of sourcemap files, with each node\n * being either an `OriginalSource` \"leaf\" or a `SourceMapTree` composed of\n * `OriginalSource`s and `SourceMapTree`s.\n *\n * Every sourcemap is composed of a collection of source files and mappings\n * into locations of those source files. When we generate a `SourceMapTree` for\n * the sourcemap, we attempt to load each source file's own sourcemap. If it\n * does not have an associated sourcemap, it is considered an original,\n * unmodified source file.\n */\nfunction buildSourceMapTree(input, loader) {\n  const maps = asArray(input).map(m => new TraceMap(m, ''));\n  const map = maps.pop();\n  for (let i = 0; i < maps.length; i++) {\n    if (maps[i].sources.length > 1) {\n      throw new Error(`Transformation map ${i} must have exactly one source file.\\n` + 'Did you specify these with the most recent transformation maps first?');\n    }\n  }\n  let tree = build(map, loader, '', 0);\n  for (let i = maps.length - 1; i >= 0; i--) {\n    tree = MapSource(maps[i], [tree]);\n  }\n  return tree;\n}\nfunction build(map, loader, importer, importerDepth) {\n  const {\n    resolvedSources,\n    sourcesContent\n  } = map;\n  const depth = importerDepth + 1;\n  const children = resolvedSources.map((sourceFile, i) => {\n    // The loading context gives the loader more information about why this file is being loaded\n    // (eg, from which importer). It also allows the loader to override the location of the loaded\n    // sourcemap/original source, or to override the content in the sourcesContent field if it's\n    // an unmodified source file.\n    const ctx = {\n      importer,\n      depth,\n      source: sourceFile || '',\n      content: undefined\n    };\n    // Use the provided loader callback to retrieve the file's sourcemap.\n    // TODO: We should eventually support async loading of sourcemap files.\n    const sourceMap = loader(ctx.source, ctx);\n    const {\n      source,\n      content\n    } = ctx;\n    // If there is a sourcemap, then we need to recurse into it to load its source files.\n    if (sourceMap) return build(new TraceMap(sourceMap, source), loader, source, depth);\n    // Else, it's an an unmodified source file.\n    // The contents of this unmodified source file can be overridden via the loader context,\n    // allowing it to be explicitly null or a string. If it remains undefined, we fall back to\n    // the importing sourcemap's `sourcesContent` field.\n    const sourceContent = content !== undefined ? content : sourcesContent ? sourcesContent[i] : null;\n    return OriginalSource(source, sourceContent);\n  });\n  return MapSource(map, children);\n}\n\n/**\n * A SourceMap v3 compatible sourcemap, which only includes fields that were\n * provided to it.\n */\nclass SourceMap {\n  constructor(map, options) {\n    const out = options.decodedMappings ? decodedMap(map) : encodedMap(map);\n    this.version = out.version; // SourceMap spec says this should be first.\n    this.file = out.file;\n    this.mappings = out.mappings;\n    this.names = out.names;\n    this.sourceRoot = out.sourceRoot;\n    this.sources = out.sources;\n    if (!options.excludeContent) {\n      this.sourcesContent = out.sourcesContent;\n    }\n  }\n  toString() {\n    return JSON.stringify(this);\n  }\n}\n\n/**\n * Traces through all the mappings in the root sourcemap, through the sources\n * (and their sourcemaps), all the way back to the original source location.\n *\n * `loader` will be called every time we encounter a source file. If it returns\n * a sourcemap, we will recurse into that sourcemap to continue the trace. If\n * it returns a falsey value, that source file is treated as an original,\n * unmodified source file.\n *\n * Pass `excludeContent` to exclude any self-containing source file content\n * from the output sourcemap.\n *\n * Pass `decodedMappings` to receive a SourceMap with decoded (instead of\n * VLQ encoded) mappings.\n */\nfunction remapping(input, loader, options) {\n  const opts = typeof options === 'object' ? options : {\n    excludeContent: !!options,\n    decodedMappings: false\n  };\n  const tree = buildSourceMapTree(input, loader);\n  return new SourceMap(traceMappings(tree), opts);\n}\nexport { remapping as default };","map":{"version":3,"mappings":";;AAqBA,MAAMA,kBAAkB,GAAG;EACzBC,MAAM,EAAE,IAAI;EACZC,MAAM,EAAE,IAAI;EACZC,IAAI,EAAE,IAAI;EACVC,IAAI,EAAE,IAAI;EACVC,OAAO,EAAE;CACV;AACD,MAAMC,aAAa,GAAc,EAAE;AAkBnC,SAASC,MAAM,CACbC,GAAoB,EACpBC,OAAkB,EAClBR,MAAc,EACdI,OAAsB;EAEtB,OAAO;IACLG,GAAG;IACHC,OAAO;IACPR,MAAM;IACNI;GACM;AACV;AAEA;;;AAGG;AACa,kBAAS,CAACG,GAAa,EAAEC,OAAkB;EACzD,OAAOF,MAAM,CAACC,GAAG,EAAEC,OAAO,EAAE,EAAE,EAAE,IAAI,CAAC;AACvC;AAEA;;;AAGG;AACa,uBAAc,CAACR,MAAc,EAAEI,OAAsB;EACnE,OAAOE,MAAM,CAAC,IAAI,EAAED,aAAa,EAAEL,MAAM,EAAEI,OAAO,CAAC;AACrD;AAEA;;;AAGG;AACG,SAAUK,aAAa,CAACC,IAAe;EAC3C,MAAMC,GAAG,GAAG,IAAIC,UAAU,CAAC;IAAEC,IAAI,EAAEH,IAAI,CAACH,GAAG,CAACM;EAAI,CAAE,CAAC;EACnD,MAAM;IAAEL,OAAO,EAAEM,WAAW;IAAEP;EAAG,CAAE,GAAGG,IAAI;EAC1C,MAAMK,SAAS,GAAGR,GAAG,CAACS,KAAK;EAC3B,MAAMC,YAAY,GAAGC,eAAe,CAACX,GAAG,CAAC;EAEzC,KAAK,IAAIY,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,YAAY,CAACG,MAAM,EAAED,CAAC,EAAE,EAAE;IAC5C,MAAME,QAAQ,GAAGJ,YAAY,CAACE,CAAC,CAAC;IAEhC,IAAIG,UAAU,GAAG,IAAI;IACrB,IAAIC,cAAc,GAAG,IAAI;IACzB,IAAIC,gBAAgB,GAAG,IAAI;IAE3B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,QAAQ,CAACD,MAAM,EAAEK,CAAC,EAAE,EAAE;MACxC,MAAMC,OAAO,GAAGL,QAAQ,CAACI,CAAC,CAAC;MAC3B,MAAME,MAAM,GAAGD,OAAO,CAAC,CAAC,CAAC;MACzB,IAAIE,MAAM,GAAkC7B,kBAAkB;;;MAI9D,IAAI2B,OAAO,CAACN,MAAM,KAAK,CAAC,EAAE;QACxB,MAAMpB,MAAM,GAAGc,WAAW,CAACY,OAAO,CAAC,CAAC,CAAC,CAAC;QACtCE,MAAM,GAAGC,mBAAmB,CAC1B7B,MAAM,EACN0B,OAAO,CAAC,CAAC,CAAC,EACVA,OAAO,CAAC,CAAC,CAAC,EACVA,OAAO,CAACN,MAAM,KAAK,CAAC,GAAGL,SAAS,CAACW,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE,CAClD;;;QAID,IAAIE,MAAM,IAAI,IAAI,EAAE;MACrB;;;MAID,MAAM;QAAE3B,MAAM;QAAEC,IAAI;QAAEC,IAAI;QAAEC,OAAO;QAAEJ;MAAM,CAAE,GAAG4B,MAAM;MACtD,IAAI1B,IAAI,KAAKqB,cAAc,IAAItB,MAAM,KAAKuB,gBAAgB,IAAIxB,MAAM,KAAKsB,UAAU,EAAE;QACnF;MACD;MACDC,cAAc,GAAGrB,IAAI;MACrBsB,gBAAgB,GAAGvB,MAAM;MACzBqB,UAAU,GAAGtB,MAAM;;MAGlB8B,UAAkB,CAACnB,GAAG,EAAEQ,CAAC,EAAEQ,MAAM,EAAE3B,MAAM,EAAEE,IAAI,EAAED,MAAM,EAAEE,IAAI,CAAC;MAC/D,IAAIC,OAAO,IAAI,IAAI,EAAE2B,gBAAgB,CAACpB,GAAG,EAAEX,MAAM,EAAEI,OAAO,CAAC;IAC5D;EACF;EAED,OAAOO,GAAG;AACZ;AAEA;;;AAGG;AACG,SAAUkB,mBAAmB,CACjC7B,MAAe,EACfE,IAAY,EACZD,MAAc,EACdE,IAAY;EAEZ,IAAI,CAACH,MAAM,CAACO,GAAG,EAAE;IACf,OAAO;MAAEN,MAAM;MAAEC,IAAI;MAAEC,IAAI;MAAEH,MAAM,EAAEA,MAAM,CAACA,MAAM;MAAEI,OAAO,EAAEJ,MAAM,CAACI;IAAO,CAAE;EAC9E;EAED,MAAMsB,OAAO,GAAGM,YAAY,CAAChC,MAAM,CAACO,GAAG,EAAEL,IAAI,EAAED,MAAM,CAAC;;EAGtD,IAAIyB,OAAO,IAAI,IAAI,EAAE,OAAO,IAAI;;;EAGhC,IAAIA,OAAO,CAACN,MAAM,KAAK,CAAC,EAAE,OAAOrB,kBAAkB;EAEnD,OAAO8B,mBAAmB,CACxB7B,MAAM,CAACQ,OAAO,CAACkB,OAAO,CAAC,CAAC,CAAC,CAAC,EAC1BA,OAAO,CAAC,CAAC,CAAC,EACVA,OAAO,CAAC,CAAC,CAAC,EACVA,OAAO,CAACN,MAAM,KAAK,CAAC,GAAGpB,MAAM,CAACO,GAAG,CAACS,KAAK,CAACU,OAAO,CAAC,CAAC,CAAC,CAAC,GAAGvB,IAAI,CAC3D;AACH;AC1JA,SAAS8B,OAAO,CAAIC,KAAc;EAChC,IAAIC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE,OAAOA,KAAK;EACtC,OAAO,CAACA,KAAK,CAAC;AAChB;AAEA;;;;;;;;;;AAUG;AACW,SAAUG,kBAAkB,CACxCC,KAAwC,EACxCC,MAAuB;EAEvB,MAAMC,IAAI,GAAGP,OAAO,CAACK,KAAK,CAAC,CAAC/B,GAAG,CAAEkC,CAAC,IAAK,IAAIC,QAAQ,CAACD,CAAC,EAAE,EAAE,CAAC,CAAC;EAC3D,MAAMlC,GAAG,GAAGiC,IAAI,CAACG,GAAG,EAAG;EAEvB,KAAK,IAAIxB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqB,IAAI,CAACpB,MAAM,EAAED,CAAC,EAAE,EAAE;IACpC,IAAIqB,IAAI,CAACrB,CAAC,CAAC,CAACX,OAAO,CAACY,MAAM,GAAG,CAAC,EAAE;MAC9B,MAAM,IAAIwB,KAAK,CACb,sBAAsBzB,CAAwC,0CAC5D,uEAAuE,CAC1E;IACF;EACF;EAED,IAAIT,IAAI,GAAGmC,KAAK,CAACtC,GAAG,EAAEgC,MAAM,EAAE,EAAE,EAAE,CAAC,CAAC;EACpC,KAAK,IAAIpB,CAAC,GAAGqB,IAAI,CAACpB,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IACzCT,IAAI,GAAGoC,SAAS,CAACN,IAAI,CAACrB,CAAC,CAAC,EAAE,CAACT,IAAI,CAAC,CAAC;EAClC;EACD,OAAOA,IAAI;AACb;AAEA,SAASmC,KAAK,CACZtC,GAAa,EACbgC,MAAuB,EACvBQ,QAAgB,EAChBC,aAAqB;EAErB,MAAM;IAAEC,eAAe;IAAEC;EAAc,CAAE,GAAG3C,GAAG;EAE/C,MAAM4C,KAAK,GAAGH,aAAa,GAAG,CAAC;EAC/B,MAAMI,QAAQ,GAAGH,eAAe,CAAC1C,GAAG,CAAC,CAAC8C,UAAyB,EAAElC,CAAS,KAAa;;;;;IAKrF,MAAMmC,GAAG,GAAkB;MACzBP,QAAQ;MACRI,KAAK;MACLnD,MAAM,EAAEqD,UAAU,IAAI,EAAE;MACxBjD,OAAO,EAAEmD;KACV;;;IAID,MAAMC,SAAS,GAAGjB,MAAM,CAACe,GAAG,CAACtD,MAAM,EAAEsD,GAAG,CAAC;IAEzC,MAAM;MAAEtD,MAAM;MAAEI;IAAO,CAAE,GAAGkD,GAAG;;IAG/B,IAAIE,SAAS,EAAE,OAAOX,KAAK,CAAC,IAAIH,QAAQ,CAACc,SAAS,EAAExD,MAAM,CAAC,EAAEuC,MAAM,EAAEvC,MAAM,EAAEmD,KAAK,CAAC;;;;;IAMnF,MAAMM,aAAa,GACjBrD,OAAO,KAAKmD,SAAS,GAAGnD,OAAO,GAAG8C,cAAc,GAAGA,cAAc,CAAC/B,CAAC,CAAC,GAAG,IAAI;IAC7E,OAAOuC,cAAc,CAAC1D,MAAM,EAAEyD,aAAa,CAAC;EAC9C,CAAC,CAAC;EAEF,OAAOX,SAAS,CAACvC,GAAG,EAAE6C,QAAQ,CAAC;AACjC;;ACjFA;;;AAGG;AACW,MAAOO,SAAS;EAS5BC,WAAY,IAAe,EAAEC,OAAgB;IAC3C,MAAMC,GAAG,GAAGD,OAAO,CAAC3C,eAAe,GAAG6C,UAAU,CAACxD,GAAG,CAAC,GAAGyD,UAAU,CAACzD,GAAG,CAAC;IACvE,IAAI,CAAC0D,OAAO,GAAGH,GAAG,CAACG,OAAO,CAAC;IAC3B,IAAI,CAACpD,IAAI,GAAGiD,GAAG,CAACjD,IAAI;IACpB,IAAI,CAACqD,QAAQ,GAAGJ,GAAG,CAACI,QAAiC;IACrD,IAAI,CAAClD,KAAK,GAAG8C,GAAG,CAAC9C,KAA2B;IAE5C,IAAI,CAACmD,UAAU,GAAGL,GAAG,CAACK,UAAU;IAEhC,IAAI,CAAC3D,OAAO,GAAGsD,GAAG,CAACtD,OAA+B;IAClD,IAAI,CAACqD,OAAO,CAACO,cAAc,EAAE;MAC3B,IAAI,CAAClB,cAAc,GAAGY,GAAG,CAACZ,cAA6C;IACxE;;EAGHmB,QAAQ;IACN,OAAOC,IAAI,CAACC,SAAS,CAAC,IAAI,CAAC;;AAE9B;;ACpBD;;;;;;;;;;;;;;AAcG;AACqB,kBAAS,CAC/BjC,KAAwC,EACxCC,MAAuB,EACvBsB,OAA2B;EAE3B,MAAMW,IAAI,GACR,OAAOX,OAAO,KAAK,QAAQ,GAAGA,OAAO,GAAG;IAAEO,cAAc,EAAE,CAAC,CAACP,OAAO;IAAE3C,eAAe,EAAE;EAAK,CAAE;EAC/F,MAAMR,IAAI,GAAG2B,kBAAkB,CAACC,KAAK,EAAEC,MAAM,CAAC;EAC9C,OAAO,IAAIoB,SAAS,CAAClD,aAAa,CAACC,IAAI,CAAC,EAAE8D,IAAI,CAAC;AACjD","names":["SOURCELESS_MAPPING","source","column","line","name","content","EMPTY_SOURCES","Source","map","sources","traceMappings","tree","gen","GenMapping","file","rootSources","rootNames","names","rootMappings","decodedMappings","i","length","segments","lastSource","lastSourceLine","lastSourceColumn","j","segment","genCol","traced","originalPositionFor","addSegment","setSourceContent","traceSegment","asArray","value","Array","isArray","buildSourceMapTree","input","loader","maps","m","TraceMap","pop","Error","build","MapSource","importer","importerDepth","resolvedSources","sourcesContent","depth","children","sourceFile","ctx","undefined","sourceMap","sourceContent","OriginalSource","SourceMap","constructor","options","out","decodedMap","encodedMap","version","mappings","sourceRoot","excludeContent","toString","JSON","stringify","opts"],"sources":["../../src/source-map-tree.ts","../../src/build-source-map-tree.ts","../../src/source-map.ts","../../src/remapping.ts"],"sourcesContent":[null,null,null,null]},"metadata":{},"sourceType":"module","externalDependencies":[]}